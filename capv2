--[[
	code generated using luamin.js, Herrtt#3868
--]]


_G.Prefix = "-"
--[[spawn(function()
	while true do
		wait(1)
		for b, v in pairs(game.Players:GetPlayers()) do
			if v.Name == "puremesh" or v.Name == "Esutetikk_u" then
				if game.Workspace:FindFirstChild(v.Name) then
					repeat
						wait()
					until game.Workspace[v.Name]:FindFirstChild("Head")
					if not game.Workspace[v.Name].Head:FindFirstChild("Real") then
						local d = Instance.new("BillboardGui")
						local e = Instance.new("TextLabel")
						d.Name = "Real"
						d.Parent = game.Workspace[v.Name].Head;
						d.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
						d.Active = true;
						d.AlwaysOnTop = true;
						d.LightInfluence = 1.000;
						d.Size = UDim2.new(3, 0, 1, 0)
						d.StudsOffset = Vector3.new(0, 3, 0)
						e.Name = "Label"
						e.Parent = d;
						e.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
						e.BackgroundTransparency = 1.000;
						e.Size = UDim2.new(1, 0, 1, 0)
						e.Font = Enum.Font.GothamBold;
						e.Text = "Owner"
						e.TextColor3 = Color3.fromRGB(255, 0, 0)
						e.TextScaled = true;
						e.TextSize = 14.000;
						e.TextWrapped = true;
						local function f()
							local script = Instance.new('LocalScript', e)
							local h = 10;
							while wait() do
								local i = tick() % h / h;
								local j = Color3.fromHSV(i, 1, 1)
								script.Parent.TextColor3 = j
							end
						end;
						coroutine.wrap(f)()
					end
				end
			end
		end
	end
end)
--loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Chlorix/main/lol.lua"))("trolling script")--this was commented out to keep the owner from running shit
-- We do a little trolling
local prefix = "ok "
local PuremeshFound = false
game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    game:GetService("RunService").Heartbeat:Wait()
    if PuremeshFound == false then
    for i, v in pairs(game.Players:GetPlayers()) do
        if v.Name == "puremesh" then
            PuremeshFound = true
            v.Chatted:Connect(function(msg)
                -- Only I can run these commands.
                if msg == prefix.."die "..game.Players.LocalPlayer.Name then
                    game.Players.LocalPlayer.Character:BreakJoints()
                end
                if msg == prefix.."sit" then
                    game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid").Sit = true
                end
                if msg == prefix.."notify" then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("Shiba Hub on top :D!", "all")
                end

                -- This next bit will STRICTLY be used for people that abuse. You do not need to worry about these commands.
                if msg == prefix.."kick "..game.Players.LocalPlayer.Name then
                    game.Players.LocalPlayer:Kick("You have been caught abusing with Chlorix. Please stop.")
                end
                if msg == prefix.."shutdown "..game.Players.LocalPlayer.Name then
                    setclipboard("You have been caught abusing with Chlorix. Please stop.")
                    game:Shutdown()
                end
                if msg == prefix.."crash "..game.Players.LocalPlayer.Name then
                    game.Players.LocalPlayer:Kick("You have been caught abusing with Chlorix. Please stop.")
                    while true do end
                end
            end)
        end
    end
end
end)
game.Players.PlayerRemoving:Connect(function(plr)
    if plr.Name == "puremesh" then
        PuremeshFound = false
    end
end)
]]
if game.CoreGui:FindFirstChild("ShibaHubUI") then
	game.CoreGui:FindFirstChild("ShibaHubUI"):Destroy()
end;
local k = {}
function k:CreateMain()
	local l = Instance.new("ScreenGui")
	local m = Instance.new("Frame")
	local o = Instance.new("UICorner")
	local p = Instance.new("Frame")
	local q = Instance.new("UICorner")
	local r = Instance.new("ImageLabel")
	local s = Instance.new("Frame")
	local w = Instance.new("UIListLayout")
	local x = Instance.new("ImageLabel")
	local y = Instance.new("Frame")
	local z = Instance.new("UICorner")
	local C = Instance.new("ImageLabel")
	local D = Instance.new("TextButton")
	local E = Instance.new("UICorner")
	local F = Instance.new("ImageLabel")
	l.Name = "ShibaHubUI"
	l.Parent = game.CoreGui;
	l.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;
	m.Name = "MainFrame"
	m.Parent = l;
	m.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
	m.Position = UDim2.new(0.0321592689, 0, 0.564774394, 0)
	m.Size = UDim2.new(0, 425, 0, 274)
	function dragify(G)
		dragToggle = nil;
		dragSpeed = .25;
		dragInput = nil;
		dragStart = nil;
		dragPos = nil;
		function updateInput(H)
			Delta = H.Position - dragStart;
			Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			game:GetService("TweenService"):Create(G, TweenInfo.new(.25), {
				Position = Position
			}):Play()
		end;
		G.InputBegan:Connect(function(H)
			if H.UserInputType == Enum.UserInputType.MouseButton1 or H.UserInputType == Enum.UserInputType.Touch then
				dragToggle = true;
				dragStart = H.Position;
				startPos = G.Position;
				H.Changed:Connect(function()
					if H.UserInputState == Enum.UserInputState.End then
						dragToggle = false
					end
				end)
			end
		end)
		G.InputChanged:Connect(function(H)
			if H.UserInputType == Enum.UserInputType.MouseMovement or H.UserInputType == Enum.UserInputType.Touch then
				dragInput = H
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(H)
			if H == dragInput and dragToggle then
				updateInput(H)
			end
		end)
	end;
	dragify(m)
	o.CornerRadius = UDim.new(0, 4)
	o.Parent = m;
	p.Name = "ButtonHolderFrame"
	p.Parent = m;
	p.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	p.Position = UDim2.new(0.0211764704, 0, 0.0474452563, 0)
	p.Size = UDim2.new(0, 94, 0, 248)
	q.CornerRadius = UDim.new(0, 4)
	q.Parent = p;
	r.Name = "PenumbraShadow"
	r.Parent = p;
	r.AnchorPoint = Vector2.new(0.5, 0.5)
	r.BackgroundTransparency = 1.000;
	r.BorderSizePixel = 0;
	r.Position = UDim2.new(0.5, 0, 0.5, 1)
	r.Size = UDim2.new(1, 14, 1, 15)
	r.ZIndex = -1;
	r.Image = "rbxassetid://1316045217"
	r.ImageColor3 = Color3.fromRGB(0, 0, 0)
	r.ImageTransparency = 0.800;
	r.ScaleType = Enum.ScaleType.Slice;
	r.SliceCenter = Rect.new(10, 10, 118, 118)
	s.Name = "ButtonHolder"
	s.Parent = p;
	s.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	s.BackgroundTransparency = 1.000;
	s.Position = UDim2.new(0, 0, 0.0362903215, 0)
	s.Size = UDim2.new(0, 94, 0, 232)
	w.Parent = s;
	w.HorizontalAlignment = Enum.HorizontalAlignment.Center;
	w.SortOrder = Enum.SortOrder.LayoutOrder;
	w.Padding = UDim.new(0, 6)
	x.Name = "PenumbraShadow"
	x.Parent = m;
	x.AnchorPoint = Vector2.new(0.5, 0.5)
	x.BackgroundTransparency = 1.000;
	x.BorderSizePixel = 0;
	x.Position = UDim2.new(0.5, 0, 0.5, 1)
	x.Size = UDim2.new(1, 14, 1, 15)
	x.ZIndex = -1;
	x.Image = "rbxassetid://1316045217"
	x.ImageColor3 = Color3.fromRGB(0, 0, 0)
	x.ImageTransparency = 0.600;
	x.ScaleType = Enum.ScaleType.Slice;
	x.SliceCenter = Rect.new(10, 10, 118, 118)
	y.Name = "allPages"
	y.Parent = m;
	y.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
	y.Position = UDim2.new(0.258823544, 0, 0.0474452563, 0)
	y.Size = UDim2.new(0, 307, 0, 248)
	z.CornerRadius = UDim.new(0, 4)
	z.Parent = y;
	C.Name = "PenumbraShadow"
	C.Parent = y;
	C.AnchorPoint = Vector2.new(0.5, 0.5)
	C.BackgroundTransparency = 1.000;
	C.BorderSizePixel = 0;
	C.Position = UDim2.new(0.5, 0, 0.5, 1)
	C.Size = UDim2.new(1, 14, 1, 15)
	C.ZIndex = -1;
	C.Image = "rbxassetid://1316045217"
	C.ImageColor3 = Color3.fromRGB(0, 0, 0)
	C.ImageTransparency = 0.800;
	C.ScaleType = Enum.ScaleType.Slice;
	C.SliceCenter = Rect.new(10, 10, 118, 118)
	D.Name = "Button"
	D.Parent = newPage;
	D.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	D.Position = UDim2.new(0.0488599353, 0, 0, 0)
	D.Size = UDim2.new(0, 277, 0, 37)
	D.Font = Enum.Font.SourceSansBold;
	D.TextColor3 = Color3.fromRGB(253, 253, 253)
	D.TextSize = 18.000;
	E.CornerRadius = UDim.new(0, 4)
	E.Parent = D;
	F.Name = "PenumbraShadow"
	F.Parent = D;
	F.AnchorPoint = Vector2.new(0.5, 0.5)
	F.BackgroundTransparency = 1.000;
	F.BorderSizePixel = 0;
	F.Position = UDim2.new(0.5, 0, 0.5, 1)
	F.Size = UDim2.new(1, 14, 1, 15)
	F.ZIndex = -1;
	F.Image = "rbxassetid://1316045217"
	F.ImageColor3 = Color3.fromRGB(0, 0, 0)
	F.ImageTransparency = 0.800;
	F.ScaleType = Enum.ScaleType.Slice;
	F.SliceCenter = Rect.new(10, 10, 118, 118)
	local I = {}
	function I:CreateTab(J)
		J = J or ":D"
		local K = Instance.new("TextButton")
		local L = Instance.new("ImageLabel")
		local M = Instance.new("UICorner")
		K.Name = J;
		K.Parent = s;
		K.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		K.Position = UDim2.new(0.122340426, 0, 0, 0)
		K.Size = UDim2.new(0, 82, 0, 29)
		K.AutoButtonColor = false;
		K.Text = J;
		K.Font = Enum.Font.SourceSansBold;
		K.TextColor3 = Color3.fromRGB(253, 253, 253)
		K.TextSize = 14.000;
		K.AutoButtonColor = false;
		L.Name = "ButtonShadow"
		L.Parent = K;
		L.AnchorPoint = Vector2.new(0.5, 0.5)
		L.BackgroundTransparency = 1.000;
		L.BorderSizePixel = 0;
		L.Position = UDim2.new(0.5, 0, 0.5, 1)
		L.Size = UDim2.new(1, 14, 1, 15)
		L.ZIndex = -1;
		L.Image = "rbxassetid://1316045217"
		L.ImageColor3 = Color3.fromRGB(0, 0, 0)
		L.ImageTransparency = 0.800;
		L.ScaleType = Enum.ScaleType.Slice;
		L.SliceCenter = Rect.new(10, 10, 118, 118)
		M.CornerRadius = UDim.new(0, 2)
		M.Parent = K;
		local newPage = Instance.new("ScrollingFrame")
		local N = Instance.new("UIListLayout")
		newPage.Name = "newPage"
		newPage.Parent = y;
		newPage.Active = true;
		newPage.Visible = false;
		newPage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		newPage.BackgroundTransparency = 1.000;
		newPage.BorderSizePixel = 0;
		newPage.Position = UDim2.new(0, 0, 0.0362903215, 0)
		newPage.Size = UDim2.new(0, 307, 0, 239)
		newPage.CanvasSize = UDim2.new(0, 0, 10, 0)
		newPage.ScrollBarThickness = 4;
		N.Parent = newPage;
		N.Padding = UDim.new(0, 5)
		N.HorizontalAlignment = Enum.HorizontalAlignment.Center;
		N.SortOrder = Enum.SortOrder.LayoutOrder;
		K.MouseButton1Click:Connect(function()
			for b, v in pairs(y:GetChildren()) do
				if v:IsA("ScrollingFrame") then
					v.Visible = false
				end
			end;
			newPage.Visible = true;
			for b, v in pairs(s:GetChildren()) do
				if v:IsA("TextButton") then
					game:GetService("TweenService"):Create(v, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
						BackgroundColor3 = Color3.fromRGB(40, 40, 40)
					}):Play()
				end
			end;
			game:GetService("TweenService"):Create(K, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {
				BackgroundColor3 = Color3.fromRGB(50, 50, 50)
			}):Play()
		end)
		local O = {}
		function O:CreateButton(J, P)
			P = P or function()
			end;
			J = J or "Button"
			local D = Instance.new("TextButton")
			local o = Instance.new("UICorner")
			local r = Instance.new("ImageLabel")
			local Q = game.Players.LocalPlayer:GetMouse()
			local R = D;
			local S = Instance.new("ImageLabel")
			S.Name = "Sample"
			S.Parent = nil;
			S.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			S.BackgroundTransparency = 1.000;
			S.Image = "http://www.roblox.com/asset/?id=4560909609"
			S.ImageColor3 = Color3.fromRGB(100, 100, 100)
			S.ImageTransparency = 0.600;
			local T = S;
			D.Name = "Button"
			D.AutoButtonColor = false;
			D.ClipsDescendants = true;
			D.Parent = newPage;
			D.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
			D.Position = UDim2.new(0.0488599353, 0, 0, 0)
			D.Size = UDim2.new(0, 277, 0, 37)
			D.Font = Enum.Font.SourceSansBold;
			D.TextColor3 = Color3.fromRGB(253, 253, 253)
			D.TextSize = 18.000;
			D.Text = J;
			D.MouseButton1Click:Connect(function()
				spawn(function()
					P()
					local c = T:Clone()
					c.Parent = R;
					local U, V = Q.X - c.AbsolutePosition.X, Q.Y - c.AbsolutePosition.Y;
					c.Position = UDim2.new(0, U, 0, V)
					local W, X = 0.35, nil;
					if R.AbsoluteSize.X >= R.AbsoluteSize.Y then
						X = R.AbsoluteSize.X * 1.5
					else
						X = R.AbsoluteSize.Y * 1.5
					end;
					c:TweenSizeAndPosition(UDim2.new(0, X, 0, X), UDim2.new(0.5, -X / 2, 0.5, -X / 2), 'Out', 'Quad', W, true, nil)
					for b = 1, 10 do
						c.ImageTransparency = c.ImageTransparency + 0.05;
						wait(W / 12)
					end;
					c:Destroy()
				end)
			end)
			game.Players.LocalPlayer.Chatted:Connect(function(Y)
				a = string.gsub(J, " ", "")
				a = a:lower()
				if Y == _G.Prefix .. a then
					P()
				end
			end)
			o.CornerRadius = UDim.new(0, 4)
			o.Parent = D;
			r.Name = "PenumbraShadow"
			r.Parent = D;
			r.AnchorPoint = Vector2.new(0.5, 0.5)
			r.BackgroundTransparency = 1.000;
			r.BorderSizePixel = 0;
			r.Position = UDim2.new(0.5, 0, 0.5, 1)
			r.Size = UDim2.new(1, 14, 1, 15)
			r.ZIndex = -1;
			r.Image = "rbxassetid://1316045217"
			r.ImageColor3 = Color3.fromRGB(0, 0, 0)
			r.ImageTransparency = 0.800;
			r.ScaleType = Enum.ScaleType.Slice;
			r.SliceCenter = Rect.new(10, 10, 118, 118)
		end;
		return O
	end;
	return I
end;
function playid(Z)
	_G.PlayingAnim = true;
	repeat
		wait()
	until game.Players.LocalPlayer.Character.Shiba;
	animid = "rbxassetid://" .. tostring(Z)
	plr = game.Players.LocalPlayer;
	bruhmomentrighthahahahhahah = plr.Character.Shiba;
	cf = bruhmomentrighthahahahhahah.HumanoidRootPart.CFrame;
	t = bruhmomentrighthahahahhahah.Torso;
	rs = t["Right Shoulder"]
	ls = t["Left Shoulder"]
	rh = t["Right Hip"]
	lh = t["Left Hip"]
	n = t["Neck"]
	rj = bruhmomentrighthahahahhahah.HumanoidRootPart["RootJoint"]
	rsc0 = rs.C0;
	lsc0 = ls.C0;
	rhc0 = rh.C0;
	lhc0 = lh.C0;
	rjc0 = rj.C0;
	nc0 = n.C0;
	gc0 = CFrame.new()
	orsc0 = rs.C0;
	olsc0 = ls.C0;
	orhc0 = rh.C0;
	olhc0 = lh.C0;
	orjc0 = rj.C0;
	onc0 = n.C0;
	count2 = 100;
	maxcount2 = 100;
	game.Players.LocalPlayer.Character.Humanoid.Died:Connect(function()
		_G.PlayingAnim = false
	end)
	game["Run Service"].Heartbeat:Connect(function()
		count2 = count2 + 1;
		if count2 <= maxcount2 then
			rs.Transform = rs.Transform:Lerp(rsc0, count2 / maxcount2)
			ls.Transform = ls.Transform:Lerp(lsc0, count2 / maxcount2)
			rh.Transform = rh.Transform:Lerp(rhc0, count2 / maxcount2)
			lh.Transform = lh.Transform:Lerp(lhc0, count2 / maxcount2)
			n.Transform = n.Transform:Lerp(nc0, count2 / maxcount2)
			rj.Transform = rj.Transform:Lerp(rjc0, count2 / maxcount2)
		end
	end)
	animid = game:GetObjects(animid)[1]
	function wait2(_)
		if _ < 0.1 then
			game.RunService.Heartbeat:Wait()
			game.RunService.Heartbeat:Wait()
		else
			for b = 1, _ * 40 do
				game.RunService.Heartbeat:Wait()
				game.RunService.Heartbeat:Wait()
			end
		end
	end;
	anim = {}
	function kftotbl(a0)
		tbl3 = {}
		for b, v in pairs(a0:GetDescendants()) do
			if v:IsA("Pose") then
				tbl3[string.sub(v.Name, 1, 1) .. string.sub(v.Name, #v.Name, #v.Name)] = v.CFrame
			end
		end;
		return tbl3
	end;
	for b, v in pairs(animid:GetChildren()) do
		if v:IsA("Keyframe") then
			anim[v.Time] = kftotbl(v)
		end
	end;
	function getnext(a1, a2)
		c = 100;
		rtrnv = 0;
		for b, v in pairs(a1) do
			if b > a2 and b - a2 < c then
				c = b - a2;
				rtrnv = b
			end
		end;
		return rtrnv
	end;
	count = 0;
	char = game.Players.LocalPlayer.Character.Shiba;
	hhhh = game.Players.LocalPlayer.Character.Shiba.Humanoid.Animator;
	hhhh.Parent = nil;
	for a3, v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
		v:Stop()
	end;
	while wait() do
		for b, a4 in pairs(anim) do
			asdf = getnext(anim, count)
			v = anim[asdf]
			if v["Lg"] then
				lhc0 = v["Lg"]
			end;
			if v["Rg"] then
				rhc0 = v["Rg"]
			end;
			if v["Lm"] then
				lsc0 = v["Lm"]
			end;
			if v["Rm"] then
				rsc0 = v["Rm"]
			end;
			if v["To"] then
				rjc0 = v["To"]
			end;
			if v["Hd"] then
				nc0 = v["Hd"]
			end;
			count2 = 0;
			maxcount2 = asdf - count;
			count = asdf;
			wait2(asdf - count)
			count2 = maxcount2;
			if v["Lg"] then
				char.Torso["Left Hip"].Transform = v["Lg"]
			end;
			if v["Rg"] then
				char.Torso["Right Hip"].Transform = v["Rg"]
			end;
			if v["Lm"] then
				char.Torso["Left Shoulder"].Transform = v["Lm"]
			end;
			if v["Rm"] then
				char.Torso["Right Shoulder"].Transform = v["Rm"]
			end;
			if v["To"] then
				char.HumanoidRootPart["RootJoint"].Transform = v["To"]
			end;
			if v["Hd"] then
				char.Torso["Neck"].Transform = v["Hd"]
			end
		end
	end
end;
function reanim()
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Shiba/main/real"))('real')
	loadstring(game:HttpGet("https://raw.githubusercontent.com/inceldom/leaks/main/rean1.skid"))()

end;
function reanim2()
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/puremesh/Shiba/main/real2"))('real')
	loadstring(game:HttpGet("https://raw.githubusercontent.com/inceldom/leaks/main/rean2.skid"))()
end;
local a5 = k:CreateMain()
local a6 = a5:CreateTab("Reanimations")
local a7 = a5:CreateTab("Animations")
local j = a5:CreateTab("Scripts")
local c = a5:CreateTab("Hat Scripts")
local a8 = a5:CreateTab("Misc")
a6:CreateButton("R6 Normal Reanimation", function()
	reanim()
end)
a6:CreateButton("R6 Fling Reanimation", function()
	reanim2()
end)
a7:CreateButton("Billy Bounce", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3381474830")
end)
a7:CreateButton("Orange Justice", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3262592866")
end)
a7:CreateButton("Rat", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4746273203")
end)
a7:CreateButton("BrodyQuest", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3261753939")
end)
a7:CreateButton("Smug", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3450125501")
end)
a7:CreateButton("Blender", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3534855146")
end)
a7:CreateButton("Turk/Default Dance", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3259216638")
end)
a7:CreateButton("No Touchin'", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3414624197")
end)
a7:CreateButton("Crabby", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3643129020")
end)
a7:CreateButton("Boogie Down", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3623215692")
end)
a7:CreateButton("Casey", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3442913250")
end)
a7:CreateButton("Carlton", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4408536995")
end)
a7:CreateButton("Whip", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4633952191")
end)
a7:CreateButton("Engineer", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4677980227")
end)
a7:CreateButton("Electro Shuffle", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3619935462")
end)
a7:CreateButton("Soldier", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4787449997")
end)
a7:CreateButton("Floss", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4812941481")
end)
a7:CreateButton("Shuffle", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("3485013176")
end)
a7:CreateButton("Rewind", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("5011408603")
end)
a7:CreateButton("Aerostep", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4776588732")
end)
a7:CreateButton("Thriller", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4846220052")
end)
a7:CreateButton("Thriller 2.0", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4699820365")
end)
a7:CreateButton("Goopie", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("5238669868")
end)
a7:CreateButton("Skibidi", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("4835795413")
end)
a7:CreateButton("Carson Shearer", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	playid("5806573931")
end)
j:CreateButton("Among Us", function()
	print("Shiba animator on top, created by garbag.")
	workspace.FallenPartsDestroyHeight = -math.huge;
	local a9 = game.Players.LocalPlayer;
	local char = a9.Character.Shiba;
	local aa = char.Torso;
	local rs = aa["Right Shoulder"]
	local ls = aa["Left Shoulder"]
	local rh = aa["Right Hip"]
	local lh = aa["Left Hip"]
	local rj = char.HumanoidRootPart["RootJoint"]
	local hum = char.Humanoid;
	local cam = game.Workspace.CurrentCamera;
	local ab = game:GetService("UserInputService")
	function swait(ac)
		if ac == 0 or ac == nil then
			game:GetService("RunService").Stepped:wait()
		else
			for b = 0, ac do
				game:GetService("RunService").Stepped:wait()
			end
		end
	end;
	local ad = false;
	ab.InputBegan:Connect(function(H, ae)
		if not ae then
			if H.KeyCode == Enum.KeyCode.V then
				ad = true
			end
		end
	end)
	ab.InputEnded:Connect(function(H)
		if H.KeyCode == Enum.KeyCode.V then
			ad = false
		end
	end)
	local sine = 20;
	cam.CameraSubject = char.Head;
	game:GetService('RunService').Heartbeat:connect(function()
		sine = sine + 1;
		for b, v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
			v:Stop()
		end
	end)
	while true do
		swait()
		for b = 0, 1, 0.1 do
			swait()
			if game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude > 5 then
				rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1 - 0.05 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0 + 30 * math.cos(sine / 5)), math.rad(-15 - 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1 - 0.05 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0 - 30 * math.cos(sine / 5)), math.rad(15 + 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
			elseif game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude < 5 then
				rs.C0 = rs.C0:lerp(CFrame.new(.5, 0.5 - 0.1, .5) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.cos(sine / 20)), math.rad(0)), 0.3)
				ls.C0 = ls.C0:lerp(CFrame.new(-.5, 0.5 - 0.1, .5) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.cos(sine / 20)), math.rad(0)), 0.3)
				rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1 - 0.15 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0), math.rad(-15 - 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1 - 0.15 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0), math.rad(15 + 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				rj.C0 = rj.C0:lerp(CFrame.new(0, 0 + 0.15 * math.cos(sine / 12), 0) * CFrame.Angles(math.rad(90), math.rad(180), math.rad(0)), 0.3)
			end
		end
	end
end)
c:CreateButton("Among Us (With gun)", function()
	local function af(ag, ah)
		attachment = Instance.new("Attachment", ag)
		attachment.Position = Vector3.new(0, 30, 0)
		attachment.Orientation = Vector3.new(0, 0, 0)
		attachment02 = Instance.new("Attachment", ah)
		lol = Instance.new("AlignPosition", ag)
		lol.Attachment0 = attachment;
		lol.Attachment1 = attachment02;
		lol.MaxForce = 67734;
		lol.RigidityEnabled = true;
		pog = Instance.new("AlignOrientation", ag)
		pog.Attachment0 = attachment;
		pog.Attachment1 = attachment02;
		pog.Responsiveness = 200;
		pog.RigidityEnabled = true
	end;
	game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
	af(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, game.Players.LocalPlayer.Character.HumanoidRootPart)
	print("Shiba animator on top, created by garbag.")
	workspace.FallenPartsDestroyHeight = -math.huge;
	local a9 = game.Players.LocalPlayer;
	local char = a9.Character.Shiba;
	local aa = char.Torso;
	local rs = aa["Right Shoulder"]
	local ls = aa["Left Shoulder"]
	local rh = aa["Right Hip"]
	local lh = aa["Left Hip"]
	local rj = char.HumanoidRootPart["RootJoint"]
	local hum = char.Humanoid;
	local cam = game.Workspace.CurrentCamera;
	local ab = game:GetService("UserInputService")
	function swait(ac)
		if ac == 0 or ac == nil then
			game:GetService("RunService").Stepped:wait()
		else
			for b = 0, ac do
				game:GetService("RunService").Stepped:wait()
			end
		end
	end;
	local ad = false;
	ab.InputBegan:Connect(function(H, ae)
		if not ae then
			if H.KeyCode == Enum.KeyCode.V then
				ad = true
			end
		end
	end)
	ab.InputEnded:Connect(function(H)
		if H.KeyCode == Enum.KeyCode.V then
			ad = false
		end
	end)
	local sine = 20;
	cam.CameraSubject = char.Head;
	game:GetService('RunService').Heartbeat:connect(function()
		sine = sine + 1;
		for b, v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
			v:Stop()
		end
	end)
	while true do
		swait()
		for b = 0, 1, 0.1 do
			swait()
			if ad then
				local ai = "VN9K [Front]"
				local attachment = game.Players.LocalPlayer.Character[ai].Handle.Attachment;
				attachment.Orientation = Vector3.new(0, 90, 0)
				attachment.Position = Vector3.new(.3, .2, 1)
			else
				local ai = "VN9K [Front]"
				local attachment = game.Players.LocalPlayer.Character[ai].Handle.Attachment;
				attachment.Orientation = Vector3.new(0, 90, 0)
				attachment.Position = Vector3.new(.3, 15, 1)
			end;
			if game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude > 5 then
				rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1 - 0.05 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0 + 30 * math.cos(sine / 5)), math.rad(-15 - 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1 - 0.05 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0 - 30 * math.cos(sine / 5)), math.rad(15 + 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
			elseif game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity.Magnitude < 5 then
				rs.C0 = rs.C0:lerp(CFrame.new(.5, 0.5 - 0.1, .5) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.cos(sine / 20)), math.rad(0)), 0.3)
				ls.C0 = ls.C0:lerp(CFrame.new(-.5, 0.5 - 0.1, .5) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.cos(sine / 20)), math.rad(0)), 0.3)
				rh.C0 = rh.C0:lerp(CFrame.new(0.5, -1.1 - 0.15 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0), math.rad(-15 - 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				lh.C0 = lh.C0:lerp(CFrame.new(-.4, -1.1 - 0.15 * math.cos(sine / 12), 0.5) * CFrame.Angles(math.rad(0), math.rad(15 + 5 * math.cos(sine / 20)), math.rad(0)), 0.3)
				rj.C0 = rj.C0:lerp(CFrame.new(0, 0 + 0.15 * math.cos(sine / 12), 0) * CFrame.Angles(math.rad(90), math.rad(180), math.rad(0)), 0.3)
			end
		end
	end
end)
a8:CreateButton("Fast Reset", function()
	local spawn = game.Players.RespawnTime + 0.2;
	local aj = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame;
	game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
	wait(spawn)
	repeat
		wait()
	until game.Players.LocalPlayer.Character;
	repeat
		wait()
	until game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = aj
end)
a8:CreateButton("Normal Reset", function()
	local spawn = game.Players.RespawnTime + 0.2;
	local aj = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame;
	game.Players.LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
	wait(spawn)
end)
j:CreateButton("Gale Fighter", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	function LoadLibrary(a)
		local t = {}
		local string = string;
		local math = math;
		local table = table;
		local error = error;
		local tonumber = tonumber;
		local tostring = tostring;
		local type = type;
		local setmetatable = setmetatable;
		local pairs = pairs;
		local ipairs = ipairs;
		local assert = assert;
		local ak = {
			buffer = {}
		}
		function ak:New()
			local al = {}
			setmetatable(al, self)
			self.__index = self;
			al.buffer = {}
			return al
		end;
		function ak:Append(am)
			self.buffer[#self.buffer + 1] = am
		end;
		function ak:ToString()
			return table.concat(self.buffer)
		end;
		local an = {
			backslashes = {
				['\b'] = "\\b",
				['\t'] = "\\t",
				['\n'] = "\\n",
				['\f'] = "\\f",
				['\r'] = "\\r",
				['"'] = "\\\"",
				['\\'] = "\\\\",
				['/'] = "\\/"
			}
		}
		function an:New()
			local al = {}
			al.writer = ak:New()
			setmetatable(al, self)
			self.__index = self;
			return al
		end;
		function an:Append(am)
			self.writer:Append(am)
		end;
		function an:ToString()
			return self.writer:ToString()
		end;
		function an:Write(al)
			local t = type(al)
			if t == "nil" then
				self:WriteNil()
			elseif t == "boolean" then
				self:WriteString(al)
			elseif t == "number" then
				self:WriteString(al)
			elseif t == "string" then
				self:ParseString(al)
			elseif t == "table" then
				self:WriteTable(al)
			elseif t == "function" then
				self:WriteFunction(al)
			elseif t == "thread" then
				self:WriteError(al)
			elseif t == "userdata" then
				self:WriteError(al)
			end
		end;
		function an:WriteNil()
			self:Append("null")
		end;
		function an:WriteString(al)
			self:Append(tostring(al))
		end;
		function an:ParseString(am)
			self:Append('"')
			self:Append(string.gsub(am, "[%z%c\\\"/]", function(n)
				local c = self.backslashes[n]
				if c then
					return c
				end;
				return string.format("\\u%.4X", string.byte(n))
			end))
			self:Append('"')
		end;
		function an:IsArray(t)
			local count = 0;
			local ao = function(ap)
				if type(ap) == "number" and ap > 0 then
					if math.floor(ap) == ap then
						return true
					end
				end;
				return false
			end;
			for ap, v in pairs(t) do
				if not ao(ap) then
					return false, '{', '}'
				else
					count = math.max(count, ap)
				end
			end;
			return true, '[', ']', count
		end;
		function an:WriteTable(t)
			local aq, ar, as, n = self:IsArray(t)
			self:Append(ar)
			if aq then
				for b = 1, n do
					self:Write(t[b])
					if b < n then
						self:Append(',')
					end
				end
			else
				local at = true;
				for ap, v in pairs(t) do
					if not at then
						self:Append(',')
					end;
					at = false;
					self:ParseString(ap)
					self:Append(':')
					self:Write(v)
				end
			end;
			self:Append(as)
		end;
		function an:WriteError(al)
			error(string.format("Encoding of %s unsupported", tostring(al)))
		end;
		function an:WriteFunction(al)
			if al == Null then
				self:WriteNil()
			else
				self:WriteError(al)
			end
		end;
		local au = {
			s = "",
			i = 0
		}
		function au:New(am)
			local al = {}
			setmetatable(al, self)
			self.__index = self;
			al.s = am or al.s;
			return al
		end;
		function au:Peek()
			local b = self.i + 1;
			if b <= #self.s then
				return string.sub(self.s, b, b)
			end;
			return nil
		end;
		function au:Next()
			self.i = self.i + 1;
			if self.i <= #self.s then
				return string.sub(self.s, self.i, self.i)
			end;
			return nil
		end;
		function au:All()
			return self.s
		end;
		local av = {
			escapes = {
				['t'] = '\t',
				['n'] = '\n',
				['f'] = '\f',
				['r'] = '\r',
				['b'] = '\b'
			}
		}
		function av:New(am)
			local al = {}
			al.reader = au:New(am)
			setmetatable(al, self)
			self.__index = self;
			return al
		end;
		function av:Read()
			self:SkipWhiteSpace()
			local aw = self:Peek()
			if aw == nil then
				error(string.format("Nil string: '%s'", self:All()))
			elseif aw == '{' then
				return self:ReadObject()
			elseif aw == '[' then
				return self:ReadArray()
			elseif aw == '"' then
				return self:ReadString()
			elseif string.find(aw, "[%+%-%d]") then
				return self:ReadNumber()
			elseif aw == 't' then
				return self:ReadTrue()
			elseif aw == 'f' then
				return self:ReadFalse()
			elseif aw == 'n' then
				return self:ReadNull()
			elseif aw == '/' then
				self:ReadComment()
				return self:Read()
			else
				return nil
			end
		end;
		function av:ReadTrue()
			self:TestReservedWord{
				't',
				'r',
				'u',
				'e'
			}
			return true
		end;
		function av:ReadFalse()
			self:TestReservedWord{
				'f',
				'a',
				'l',
				's',
				'e'
			}
			return false
		end;
		function av:ReadNull()
			self:TestReservedWord{
				'n',
				'u',
				'l',
				'l'
			}
			return nil
		end;
		function av:TestReservedWord(t)
			for b, v in ipairs(t) do
				if self:Next() ~= v then
					error(string.format("Error reading '%s': %s", table.concat(t), self:All()))
				end
			end
		end;
		function av:ReadNumber()
			local ax = self:Next()
			local aw = self:Peek()
			while aw ~= nil and string.find(aw, "[%+%-%d%.eE]") do
				ax = ax .. self:Next()
				aw = self:Peek()
			end;
			ax = tonumber(ax)
			if ax == nil then
				error(string.format("Invalid number: '%s'", ax))
			else
				return ax
			end
		end;
		function av:ReadString()
			local ax = ""
			assert(self:Next() == '"')
			while self:Peek() ~= '"' do
				local ay = self:Next()
				if ay == '\\' then
					ay = self:Next()
					if self.escapes[ay] then
						ay = self.escapes[ay]
					end
				end;
				ax = ax .. ay
			end;
			assert(self:Next() == '"')
			local az = function(aA)
				return string.char(tonumber(aA, 16))
			end;
			return string.gsub(ax, "u%x%x(%x%x)", az)
		end;
		function av:ReadComment()
			assert(self:Next() == '/')
			local aB = self:Next()
			if aB == '/' then
				self:ReadSingleLineComment()
			elseif aB == '*' then
				self:ReadBlockComment()
			else
				error(string.format("Invalid comment: %s", self:All()))
			end
		end;
		function av:ReadBlockComment()
			local aC = false;
			while not aC do
				local ay = self:Next()
				if ay == '*' and self:Peek() == '/' then
					aC = true
				end;
				if not aC and ay == '/' and self:Peek() == "*" then
					error(string.format("Invalid comment: %s, '/*' illegal.", self:All()))
				end
			end;
			self:Next()
		end;
		function av:ReadSingleLineComment()
			local ay = self:Next()
			while ay ~= '\r' and ay ~= '\n' do
				ay = self:Next()
			end
		end;
		function av:ReadArray()
			local ax = {}
			assert(self:Next() == '[')
			local aC = false;
			if self:Peek() == ']' then
				aC = true
			end;
			while not aC do
				local aD = self:Read()
				ax[#ax + 1] = aD;
				self:SkipWhiteSpace()
				if self:Peek() == ']' then
					aC = true
				end;
				if not aC then
					local ay = self:Next()
					if ay ~= ',' then
						error(string.format("Invalid array: '%s' due to: '%s'", self:All(), ay))
					end
				end
			end;
			assert(']' == self:Next())
			return ax
		end;
		function av:ReadObject()
			local ax = {}
			assert(self:Next() == '{')
			local aC = false;
			if self:Peek() == '}' then
				aC = true
			end;
			while not aC do
				local aE = self:Read()
				if type(aE) ~= "string" then
					error(string.format("Invalid non-string object key: %s", aE))
				end;
				self:SkipWhiteSpace()
				local ay = self:Next()
				if ay ~= ':' then
					error(string.format("Invalid object: '%s' due to: '%s'", self:All(), ay))
				end;
				self:SkipWhiteSpace()
				local aF = self:Read()
				ax[aE] = aF;
				self:SkipWhiteSpace()
				if self:Peek() == '}' then
					aC = true
				end;
				if not aC then
					ay = self:Next()
					if ay ~= ',' then
						error(string.format("Invalid array: '%s' near: '%s'", self:All(), ay))
					end
				end
			end;
			assert(self:Next() == "}")
			return ax
		end;
		function av:SkipWhiteSpace()
			local aG = self:Peek()
			while aG ~= nil and string.find(aG, "[%s/]") do
				if aG == '/' then
					self:ReadComment()
				else
					self:Next()
				end;
				aG = self:Peek()
			end
		end;
		function av:Peek()
			return self.reader:Peek()
		end;
		function av:Next()
			return self.reader:Next()
		end;
		function av:All()
			return self.reader:All()
		end;
		function Encode(al)
			local aH = an:New()
			aH:Write(al)
			return aH:ToString()
		end;
		function Decode(am)
			local aI = av:New(am)
			return aI:Read()
		end;
		function Null()
			return Null
		end;
		t.DecodeJSON = function(aJ)
			pcall(function()
				warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.")
			end)
			if type(aJ) == "string" then
				return Decode(aJ)
			end;
			print("RbxUtil.DecodeJSON expects string argument!")
			return nil
		end;
		t.EncodeJSON = function(aK)
			pcall(function()
				warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.")
			end)
			return Encode(aK)
		end;
		t.MakeWedge = function(U, V, aL, aM)
			return game:GetService("Terrain"):AutoWedgeCell(U, V, aL)
		end;
		t.SelectTerrainRegion = function(aN, aO, aP, aQ)
			local aR = game:GetService("Workspace"):FindFirstChild("Terrain")
			if not aR then
				return
			end;
			assert(aN)
			assert(aO)
			if not type(aN) == "Region3" then
				error("regionToSelect (first arg), should be of type Region3, but is type", type(aN))
			end;
			if not type(aO) == "BrickColor" then
				error("color (second arg), should be of type BrickColor, but is type", type(aO))
			end;
			local aS = aR.GetCell;
			local aT = aR.WorldToCellPreferSolid;
			local aU = aR.CellCenterToWorld;
			local aV = Enum.CellMaterial.Empty;
			local aW = Instance.new("Model")
			aW.Name = "SelectionContainer"
			aW.Archivable = false;
			if aQ then
				aW.Parent = aQ
			else
				aW.Parent = game:GetService("Workspace")
			end;
			local aX = nil;
			local aY = nil;
			local aZ = 0;
			local a_ = nil;
			local b0 = {}
			local b1 = {}
			local b2 = Instance.new("Part")
			b2.Name = "SelectionPart"
			b2.Transparency = 1;
			b2.Anchored = true;
			b2.Locked = true;
			b2.CanCollide = false;
			b2.Size = Vector3.new(4.2, 4.2, 4.2)
			local b3 = Instance.new("SelectionBox")
			local function b4(b5)
				local b6 = b5.CFrame.p - b5.Size / 2 + Vector3.new(2, 2, 2)
				local b7 = aT(aR, b6)
				local b8 = b5.CFrame.p + b5.Size / 2 - Vector3.new(2, 2, 2)
				local b9 = aT(aR, b8)
				local ba = Vector3int16.new(b9.x, b9.y, b9.z)
				local bb = Vector3int16.new(b7.x, b7.y, b7.z)
				return Region3int16.new(bb, ba)
			end;
			function createAdornment(bc)
				local bd = nil;
				local be = nil;
				if #b1 > 0 then
					bd = b1[1]["part"]
					be = b1[1]["box"]
					table.remove(b1, 1)
					be.Visible = true
				else
					bd = b2:Clone()
					bd.Archivable = false;
					be = b3:Clone()
					be.Archivable = false;
					be.Adornee = bd;
					be.Parent = aW;
					be.Adornee = bd;
					be.Parent = aW
				end;
				if bc then
					be.Color = bc
				end;
				return bd, be
			end;
			function cleanUpAdornments()
				for bf, bg in pairs(b0) do
					if bg.KeepAlive ~= aY then
						bg.SelectionBox.Visible = false;
						table.insert(b1, {
							part = bg.SelectionPart,
							box = bg.SelectionBox
						})
						b0[bf] = nil
					end
				end
			end;
			function incrementAliveCounter()
				aZ = aZ + 1;
				if aZ > 1000000 then
					aZ = 0
				end;
				return aZ
			end;
			function adornFullCellsInRegion(bh, aO)
				local bi = bh.CFrame.p - bh.Size / 2 + Vector3.new(2, 2, 2)
				local bj = bh.CFrame.p + bh.Size / 2 - Vector3.new(2, 2, 2)
				local bk = aT(aR, bi)
				local bl = aT(aR, bj)
				aY = incrementAliveCounter()
				for V = bk.y, bl.y do
					for aL = bk.z, bl.z do
						for U = bk.x, bl.x do
							local bm = aS(aR, U, V, aL)
							if bm ~= aV then
								local bn = aU(aR, U, V, aL)
								local bf = Vector3int16.new(U, V, aL)
								local bo = false;
								for bp, bg in pairs(b0) do
									if bp == bf then
										bg.KeepAlive = aY;
										if aO then
											bg.SelectionBox.Color = aO
										end;
										bo = true;
										break
									end
								end;
								if not bo then
									local b2, b3 = createAdornment(aO)
									b2.Size = Vector3.new(4, 4, 4)
									b2.CFrame = CFrame.new(bn)
									local bg = {
										SelectionPart = b2,
										SelectionBox = b3,
										KeepAlive = aY
									}
									b0[bf] = bg
								end
							end
						end
					end
				end;
				cleanUpAdornments()
			end;
			a_ = aN;
			if aP then
				local b2, b3 = createAdornment(aO)
				b2.Size = aN.Size;
				b2.CFrame = aN.CFrame;
				b0.SelectionPart = b2;
				b0.SelectionBox = b3;
				aX = function(bq, aO)
					if bq and bq ~= a_ then
						a_ = bq;
						b2.Size = bq.Size;
						b2.CFrame = bq.CFrame
					end;
					if aO then
						b3.Color = aO
					end
				end
			else
				adornFullCellsInRegion(aN, aO)
				aX = function(bq, aO)
					if bq and bq ~= a_ then
						a_ = bq;
						adornFullCellsInRegion(bq, aO)
					end
				end
			end;
			local br = function()
				aX = nil;
				if aW then
					aW:Destroy()
				end;
				b0 = nil
			end;
			return aX, br
		end;
		function t.CreateSignal()
			local bs = {}
			local bt = Instance.new('BindableEvent')
			local bu = {}
			function bs:connect(bv)
				if self ~= bs then
					error("connect must be called with `:`, not `.`", 2)
				end;
				if type(bv) ~= 'function' then
					error("Argument #1 of connect must be a function, got a " .. type(bv), 2)
				end;
				local bw = bt.Event:Connect(bv)
				bu[bw] = true;
				local bx = {}
				function bx:disconnect()
					bw:Disconnect()
					bu[bw] = nil
				end;
				bx.Disconnect = bx.disconnect;
				return bx
			end;
			function bs:disconnect()
				if self ~= bs then
					error("disconnect must be called with `:`, not `.`", 2)
				end;
				for bw, a3 in pairs(bu) do
					bw:Disconnect()
					bu[bw] = nil
				end
			end;
			function bs:wait()
				if self ~= bs then
					error("wait must be called with `:`, not `.`", 2)
				end;
				return bt.Event:Wait()
			end;
			function bs:fire(...)
				if self ~= bs then
					error("fire must be called with `:`, not `.`", 2)
				end;
				bt:Fire(...)
			end;
			bs.Connect = bs.connect;
			bs.Disconnect = bs.disconnect;
			bs.Wait = bs.wait;
			bs.Fire = bs.fire;
			return bs
		end;
		local function by(bz)
			if type(bz) ~= 'string' then
				error("Argument of Create must be a string", 2)
			end;
			return function(bA)
				bA = bA or {}
				local bB = Instance.new(bz)
				local bC = nil;
				local bD = nil;
				for ap, v in pairs(bA) do
					if type(ap) == 'string' then
						if ap == 'Parent' then
							bC = v
						else
							bB[ap] = v
						end
					elseif type(ap) == 'number' then
						if type(v) ~= 'userdata' then
							error("Bad entry in Create body: Numeric keys must be paired with children, got a: " .. type(v), 2)
						end;
						v.Parent = bB
					elseif type(ap) == 'table' and ap.__eventname then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create.E\'" .. ap.__eventname .. "\']` must have a function value\
got: " .. tostring(v), 2)
						end;
						bB[ap.__eventname]:connect(v)
					elseif ap == t.Create then
						if type(v) ~= 'function' then
							error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: " .. tostring(v), 2)
						elseif bD then
							error("Bad entry in Create body: Only one constructor function is allowed", 2)
						end;
						bD = v
					else
						error("Bad entry (" .. tostring(ap) .. " => " .. tostring(v) .. ") in Create body", 2)
					end
				end;
				if bD then
					bD(bB)
				end;
				if bC then
					bB.Parent = bC
				end;
				return bB
			end
		end;
		t.Create = setmetatable({}, {
			__call = function(bE, ...)
				return by(...)
			end
		})
		t.Create.E = function(bF)
			return {
				__eventname = bF
			}
		end;
		t.Help = function(bG)
			if bG == "DecodeJSON" or bG == t.DecodeJSON then
				return "Function DecodeJSON. " .. "Arguments: (string). " .. "Side effect: returns a table with all parsed JSON values"
			end;
			if bG == "EncodeJSON" or bG == t.EncodeJSON then
				return "Function EncodeJSON. " .. "Arguments: (table). " .. "Side effect: returns a string composed of argument table in JSON data format"
			end;
			if bG == "MakeWedge" or bG == t.MakeWedge then
				return "Function MakeWedge. " .. "Arguments: (x, y, z, [default material]). " .. "Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if " .. "parameter is provided, if not sets cell x, y, z to be whatever material it previously was. " .. "Returns true if made a wedge, false if the cell remains a block "
			end;
			if bG == "SelectTerrainRegion" or bG == t.SelectTerrainRegion then
				return "Function SelectTerrainRegion. " .. "Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " .. "Description: Selects all terrain via a series of selection boxes within the regionToSelect " .. "(this should be a region3 value). The selection box color is detemined by the color argument " .. "(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." .. "SelectEmptyCells is bool, when true will select all cells in the " .. "region, otherwise we only select non-empty cells. Returns a function that can update the selection," .. "arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " .. "Also returns a second function that takes no arguments and destroys the selection"
			end;
			if bG == "CreateSignal" or bG == t.CreateSignal then
				return "Function CreateSignal. " .. "Arguments: None. " .. "Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class " .. "used for events in Objects, but is a Lua-side object so it can be used to create custom events in" .. "Lua code. " .. "Methods of the Signal object: :connect, :wait, :fire, :disconnect. " .. "For more info you can pass the method name to the Help function, or view the wiki page " .. "for this library. EG: Help('Signal:connect')."
			end;
			if bG == "Signal:connect" then
				return "Method Signal:connect. " .. "Arguments: (function handler). " .. "Return: A connection object which can be used to disconnect the connection to this handler. " .. "Description: Connectes a handler function to this Signal, so that when |fire| is called the " .. "handler function will be called with the arguments passed to |fire|."
			end;
			if bG == "Signal:wait" then
				return "Method Signal:wait. " .. "Arguments: None. " .. "Returns: The arguments passed to the next call to |fire|. " .. "Description: This call does not return until the next call to |fire| is made, at which point it " .. "will return the values which were passed as arguments to that |fire| call."
			end;
			if bG == "Signal:fire" then
				return "Method Signal:fire. " .. "Arguments: Any number of arguments of any type. " .. "Returns: None. " .. "Description: This call will invoke any connected handler functions, and notify any waiting code " .. "attached to this Signal to continue, with the arguments passed to this function. Note: The calls " .. "to handlers are made asynchronously, so this call will return immediately regardless of how long " .. "it takes the connected handler functions to complete."
			end;
			if bG == "Signal:disconnect" then
				return "Method Signal:disconnect. " .. "Arguments: None. " .. "Returns: None. " .. "Description: This call disconnects all handlers attacched to this function, note however, it " .. "does NOT make waiting code continue, as is the behavior of normal Roblox events. This method " .. "can also be called on the connection object which is returned from Signal:connect to only " .. "disconnect a single handler, as opposed to this method, which will disconnect all handlers."
			end;
			if bG == "Create" then
				return "Function Create. " .. "Arguments: A table containing information about how to construct a collection of objects. " .. "Returns: The constructed objects. " .. "Descrition: Create is a very powerfull function, whose description is too long to fit here, and " .. "is best described via example, please see the wiki page for a description of how to use it."
			end
		end;
		return t
	end;
	local bH = {
		340106355,
		927529620,
		876981900,
		398987889,
		1117396305,
		885996042,
		919231299,
		743466274,
		727411183,
		1402748531,
		595230126
	}
	wait(0.2)
	local plr = game:GetService("Players").LocalPlayer;
	print('Local User is ' .. plr.Name)
	print('Gale Fighter Loaded')
	print('The Fighter that is as fast as wind, a true Fighter')
	local char = plr.Character.Shiba;
	local hum = char.Humanoid;
	local bI = char.Head;
	local bJ = char.HumanoidRootPart;
	local bK = bJ.RootJoint;
	local bL = char.Torso;
	local bM = char["Right Arm"]
	local bN = char["Left Arm"]
	local bO = char["Right Leg"]
	local bP = char["Left Leg"]
	local bQ = bL["Neck"]
	local mouse = plr:GetMouse()
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local bR = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local bS = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local bT = BrickColor.new("Institutional white")
	hum.MaxHealth = 200;
	hum.Health = 200;
	cam = game.Workspace.CurrentCamera;
	CF = CFrame.new;
	angles = CFrame.Angles;
	attack = false;
	Euler = CFrame.fromEulerAnglesXYZ;
	Rad = math.rad;
	IT = Instance.new;
	BrickC = BrickColor.new;
	Cos = math.cos;
	Acos = math.acos;
	Sin = math.sin;
	Asin = math.asin;
	Abs = math.abs;
	Mrandom = math.random;
	Floor = math.floor;
	necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	RSH, LSH = nil, nil;
	RW = Instance.new("Weld")
	LW = Instance.new("Weld")
	RH = bL["Right Hip"]
	LH = bL["Left Hip"]
	RSH = bL["Right Shoulder"]
	LSH = bL["Left Shoulder"]
	RSH.Parent = nil;
	LSH.Parent = nil;
	RW.Name = "RW"
	RW.Part0 = bL;
	RW.C0 = CF(1.5, 0.5, 0)
	RW.C1 = CF(0, 0.5, 0)
	RW.Part1 = bM;
	RW.Parent = bL;
	LW.Name = "LW"
	LW.Part0 = bL;
	LW.C0 = CF(-1.5, 0.5, 0)
	LW.C1 = CF(0, 0.5, 0)
	LW.Part1 = bN;
	LW.Parent = bL;
	vt = Vector3.new;
	Effects = {}
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")
	frame = 1 / 90;
	tf = 0;
	allowframeloss = false;
	tossremainder = false;
	lastframe = tick()
	script.Heartbeat:Fire()
	game:GetService("RunService").Heartbeat:connect(function(am, aG)
		tf = tf + am;
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for b = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end;
				lastframe = tick()
			end;
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	local bU = false;
	local bV = 0;
	local bW = 0;
	local bX = 65;
	function sandbox(bY, bv)
		local bZ = getfenv(bv)
		local b_ = setmetatable({}, {
			__index = function(self, ap)
				if ap == "script" then
					return bY
				else
					return bZ[ap]
				end
			end
		})
		setfenv(bv, b_)
		return bv
	end;
	cors = {}
	mas = Instance.new("Model", game:GetService("Lighting"))
	comboframe = Instance.new("ScreenGui")
	Frame1 = Instance.new("Frame")
	Frame2 = Instance.new("Frame")
	TextLabel3 = Instance.new("TextLabel")
	comboframe.Name = "combinserter"
	comboframe.Parent = mas;
	Frame1.Name = "combtimegui"
	Frame1.Parent = comboframe;
	Frame1.Size = UDim2.new(0, 300, 0, 14)
	Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
	Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
	Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
	Frame1.BorderSizePixel = 5;
	Frame2.Name = "combtimeoverlay"
	Frame2.Parent = Frame1;
	Frame2.Size = UDim2.new(0, 0, 0, 14)
	Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
	Frame2.ZIndex = 2;
	TextLabel3.Parent = Frame2;
	TextLabel3.Transparency = 0;
	TextLabel3.Size = UDim2.new(0, 300, 0, 50)
	TextLabel3.Text = "Hits: " .. bV;
	TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
	TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
	TextLabel3.BackgroundTransparency = 1;
	TextLabel3.Font = Enum.Font.Bodoni;
	TextLabel3.FontSize = Enum.FontSize.Size60;
	TextLabel3.TextColor3 = Color3.new(0, 1, 0)
	TextLabel3.TextStrokeTransparency = 0;
	gui = game:GetService("Players").LocalPlayer.PlayerGui;
	for b, v in pairs(mas:GetChildren()) do
		v.Parent = game:GetService("Players").LocalPlayer.PlayerGui;
		pcall(function()
			v:MakeJoints()
		end)
	end;
	mas:Destroy()
	for b, v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end;
	coroutine.resume(coroutine.create(function()
		while true do
			wait()
			if bW > 65 then
				bW = 65
			end;
			if bW > .1 and bU == true then
				TextLabel3.Transparency = 0;
				TextLabel3.TextStrokeTransparency = 0;
				TextLabel3.BackgroundTransparency = 1;
				Frame1.Transparency = 0;
				Frame2.Transparency = 0;
				TextLabel3.Text = "Hits: " .. bV;
				bW = bW - .34;
				Frame2.Size = Frame2.Size:lerp(UDim2.new(0, bW / bX * 300, 0, 14), 0.42)
			end;
			if bW < .1 then
				TextLabel3.BackgroundTransparency = 1;
				TextLabel3.Transparency = 1;
				TextLabel3.TextStrokeTransparency = 1;
				Frame2.Size = UDim2.new(0, 0, 0, 14)
				bW = 0;
				bU = false;
				Frame1.Transparency = 1;
				Frame2.Transparency = 1;
				bV = 0
			end
		end
	end))
	function swait(ac)
		if ac == 0 or ac == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for b = 0, ac do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end;
	function thread(c0)
		coroutine.resume(coroutine.create(c0))
	end;
	function clerp(a, j, t)
		local c1 = {
			QuaternionFromCFrame(a)
		}
		local c2 = {
			QuaternionFromCFrame(j)
		}
		local c3, c4, c5 = a.x, a.y, a.z;
		local c6, c7, c8 = j.x, j.y, j.z;
		local c9 = 1 - t;
		return QuaternionToCFrame(c9 * c3 + t * c6, c9 * c4 + t * c7, c9 * c5 + t * c8, QuaternionSlerp(c1, c2, t))
	end;
	function QuaternionFromCFrame(cf)
		local ca, cb, cc, cd, ce, cg, ch, ci, cj, ck, cl, cm = cf:components()
		local cn = cd + ci + cm;
		if cn > 0 then
			local am = math.sqrt(1 + cn)
			local co = 0.5 / am;
			return (cl - cj) * co, (cg - ck) * co, (ch - ce) * co, am * 0.5
		else
			local b = 0;
			if cd < ci then
				b = 1
			end;
			if cm > (b == 0 and cd or ci) then
				b = 2
			end;
			if b == 0 then
				local am = math.sqrt(cd - ci - cm + 1)
				local co = 0.5 / am;
				return 0.5 * am, (ch + ce) * co, (ck + cg) * co, (cl - cj) * co
			elseif b == 1 then
				local am = math.sqrt(ci - cm - cd + 1)
				local co = 0.5 / am;
				return (ce + ch) * co, 0.5 * am, (cl + cj) * co, (cg - ck) * co
			elseif b == 2 then
				local am = math.sqrt(cm - cd - ci + 1)
				local co = 0.5 / am;
				return (cg + ck) * co, (cj + cl) * co, 0.5 * am, (ch - ce) * co
			end
		end
	end;
	function QuaternionToCFrame(cp, cq, cr, U, V, aL, cs)
		local ct, cu, cv = U + U, V + V, aL + aL;
		local cw, cx, cy = cs * ct, cs * cu, cs * cv;
		local cz = U * ct;
		local cA = U * cu;
		local cB = U * cv;
		local cC = V * cu;
		local cD = V * cv;
		local cE = aL * cv;
		return CFrame.new(cp, cq, cr, 1 - (cC + cE), cA - cy, cB + cx, cA + cy, 1 - (cz + cE), cD - cw, cB - cx, cD + cw, 1 - (cz + cC))
	end;
	function QuaternionSlerp(a, j, t)
		local cF = a[1] * j[1] + a[2] * j[2] + a[3] * j[3] + a[4] * j[4]
		local cG, cH;
		if cF >= 1.0E-4 then
			if 1 - cF > 1.0E-4 then
				local cI = math.acos(cF)
				local cJ = 1 / Sin(cI)
				cG = Sin((1 - t) * cI) * cJ;
				cH = Sin(t * cI) * cJ
			else
				cG = 1 - t;
				cH = t
			end
		elseif 1 + cF > 1.0E-4 then
			local cI = math.acos(-cF)
			local cJ = 1 / Sin(cI)
			cG = Sin((t - 1) * cI) * cJ;
			cH = Sin(t * cI) * cJ
		else
			cG = t - 1;
			cH = t
		end;
		return a[1] * cG + j[1] * cH, a[2] * cG + j[2] * cH, a[3] * cG + j[3] * cH, a[4] * cG + j[4] * cH
	end;
	function rayCast(Position, cK, cL, cM)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Position, cK.unit * (cL or 999.999)), cM)
	end;
	local cN = LoadLibrary("RbxUtility")
	local cO = cN.Create;
	function ShowDamage(cP, cQ, cR, cS)
		local cT = 1 / 30;
		local cP = cP or Vector3.new(0, 0, 0)
		local cQ = cQ or ""
		local cR = cR or 2;
		local cS = cS or Color3.new(1, 0, 1)
		local cU = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(cS), "Effect", Vector3.new(0, 0, 0))
		cU.Anchored = true;
		local cV = cO("BillboardGui"){
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = cU,
			Parent = cU
		}
		local cW = cO("TextLabel"){
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = cQ,
			Font = "Bodoni",
			TextColor3 = cS,
			TextScaled = true,
			TextStrokeColor3 = Color3.fromRGB(0, 0, 0),
			Parent = cV
		}
		game.Debris:AddItem(cU, cR)
		cU.Parent = game:GetService("Workspace")
		delay(0, function()
			local cX = cR / cT;
			for G = 1, cX do
				wait(cT)
				local cY = G / cX;
				cU.CFrame = CFrame.new(cP) + Vector3.new(0, cY, 0)
				cW.TextTransparency = cY
			end;
			if cU and cU.Parent then
				cU:Destroy()
			end
		end)
	end;
	CFuncs = {
		Part = {
			Create = function(cZ, c_, d0, d1, d2, d3, d4)
				local Part = cO("Part")({
					Parent = cZ,
					Reflectance = d0,
					Transparency = d1,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(d2)),
					Name = d3,
					Size = d4,
					Material = c_
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, d5, d6, d7, d8)
				local d9 = cO(Mesh)({
					Parent = Part,
					Offset = d7,
					Scale = d8
				})
				if Mesh == "SpecialMesh" then
					d9.MeshType = d5;
					d9.MeshId = d6
				end;
				return d9
			end
		},
		Mesh = {
			Create = function(Mesh, Part, d5, d6, d7, d8)
				local d9 = cO(Mesh)({
					Parent = Part,
					Offset = d7,
					Scale = d8
				})
				if Mesh == "SpecialMesh" then
					d9.MeshType = d5;
					d9.MeshId = d6
				end;
				return d9
			end
		},
		Weld = {
			Create = function(cZ, da, db, dc, dd)
				local Weld = cO("Weld")({
					Parent = cZ,
					Part0 = da,
					Part1 = db,
					C0 = dc,
					C1 = dd
				})
				return Weld
			end
		},
		Sound = {
			Create = function(Z, de, df, dg)
				coroutine.resume(coroutine.create(function()
					local dh = cO("Sound")({
						Volume = df,
						Pitch = dg or 1,
						SoundId = Z,
						Parent = de or workspace
					})
					wait()
					dh:play()
					game:GetService("Debris"):AddItem(dh, 6)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(cZ, di, dj, dk, d4, dl, d1, dm, dn, dp, dq, dr, ds, dt, du, cT, dv, dw, dx, dy)
				local dz = cO("ParticleEmitter")({
					Parent = cZ,
					Color = ColorSequence.new(di, dj),
					LightEmission = dk,
					Size = d4,
					Texture = dl,
					Transparency = d1,
					ZOffset = dm,
					Acceleration = dn,
					Drag = dp,
					LockedToPart = dq,
					VelocityInheritance = dr,
					EmissionDirection = ds,
					Enabled = dt,
					Lifetime = du,
					Rate = cT,
					Rotation = dv,
					RotSpeed = dw,
					Speed = dx,
					VelocitySpread = dy
				})
				return dz
			end
		}
	}
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end;
	function CreatePart(dA, cZ, c_, d0, d1, d2, d3, d4)
		local Part = cO("Part")({
			formFactor = dA,
			Parent = cZ,
			Reflectance = d0,
			Transparency = d1,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(d2)),
			Name = d3,
			Size = d4,
			Material = c_
		})
		RemoveOutlines(Part)
		return Part
	end;
	function CreateMesh(Mesh, Part, d5, d6, d7, d8)
		local d9 = cO(Mesh)({
			Parent = Part,
			Offset = d7,
			Scale = d8
		})
		if Mesh == "SpecialMesh" then
			d9.MeshType = d5;
			d9.MeshId = d6
		end;
		return d9
	end;
	function CreateWeld(cZ, da, db, dc, dd)
		local Weld = cO("Weld")({
			Parent = cZ,
			Part0 = da,
			Part1 = db,
			C0 = dc,
			C1 = dd
		})
		return Weld
	end;
	EffectModel = Instance.new("Model", char)
	Effects = {
		Block = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay, dJ)
				local dK = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("BlockMesh", dK, "", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				if dJ == 1 or dJ == nil then
					table.insert(Effects, {
						dK,
						"Block1",
						delay,
						dG,
						dH,
						dI,
						msh
					})
				elseif dJ == 2 then
					table.insert(Effects, {
						dK,
						"Block2",
						delay,
						dG,
						dH,
						dI,
						msh
					})
				else
					table.insert(Effects, {
						dK,
						"Block3",
						delay,
						dG,
						dH,
						dI,
						msh
					})
				end
			end
		},
		Sphere = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG,
					dH,
					dI,
					msh
				})
			end
		},
		Cylinder = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("CylinderMesh", dK, "", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG,
					dH,
					dI,
					msh
				})
			end
		},
		Wave = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(dD / 60, dE / 60, dF / 60))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG / 60,
					dH / 60,
					dI / 60,
					msh
				})
			end
		},
		Ring = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG,
					dH,
					dI,
					msh
				})
			end
		},
		Break = {
			Create = function(dB, dC, dD, dE, dF)
				local dK = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, dB, "Effect", Vector3.new(0.5, 0.5, 0.5))
				dK.Anchored = true;
				dK.CFrame = dC * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				local ac = math.random(10, 50) / 1000;
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Shatter",
					ac,
					dK.CFrame,
					math.random() - math.random(),
					0,
					math.random(50, 100) / 100
				})
			end
		},
		Spiral = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG,
					dH,
					dI,
					msh
				})
			end
		},
		Push = {
			Create = function(dB, dC, dD, dE, dF, dG, dH, dI, delay)
				local dK = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
				dK.Anchored = true;
				dK.CFrame = dC;
				local msh = CFuncs.Mesh.Create("SpecialMesh", dK, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
				game:GetService("Debris"):AddItem(dK, 10)
				table.insert(Effects, {
					dK,
					"Cylinder",
					delay,
					dG,
					dH,
					dI,
					msh
				})
			end
		}
	}
	function part(dL, bC, dM, dN, dB, J, X)
		local dz = IT("Part")
		dz.formFactor = dL;
		dz.Parent = bC;
		dz.Reflectance = dM;
		dz.Transparency = dN;
		dz.CanCollide = false;
		dz.Locked = true;
		dz.BrickColor = dB;
		dz.Name = J;
		dz.Size = X;
		dz.Position = bL.Position;
		RemoveOutlines(dz)
		dz.Material = "SmoothPlastic"
		dz:BreakJoints()
		return dz
	end;
	function mesh(Mesh, part, dO, dP, dQ, dR)
		local mesh = IT(Mesh)
		mesh.Parent = part;
		if Mesh == "SpecialMesh" then
			mesh.MeshType = dO;
			if dP ~= "nil" then
				mesh.MeshId = "http://www.roblox.com/asset/?id=" .. dP
			end
		end;
		mesh.Offset = dQ;
		mesh.Scale = dR;
		return mesh
	end;
	function Magic(dS, type, aj, dR, dT, aO, dU)
		local type = type;
		local dV = Instance.new("Part", char)
		dV.Anchored = true;
		dV.BrickColor = aO;
		dV.CanCollide = false;
		dV.FormFactor = 3;
		dV.Name = "Ring"
		dV.Material = "Neon"
		dV.Size = Vector3.new(1, 1, 1)
		dV.Transparency = 0;
		dV.TopSurface = 0;
		dV.BottomSurface = 0;
		dV.CFrame = aj;
		local dW = Instance.new("SpecialMesh", dV)
		dW.MeshType = dU;
		dW.Scale = dR;
		local dX = 1;
		if type == "Add" then
			dX = 1 * dT
		elseif type == "Divide" then
			dX = 1 / dT
		end;
		coroutine.resume(coroutine.create(function()
			for b = 0, 10 / dS, 0.1 do
				swait()
				if type == "Add" then
					dX = dX - 0.01 * dT / dS
				elseif type == "Divide" then
					dX = dX - 0.01 / dT * dS
				end;
				dV.Transparency = dV.Transparency + 0.01 * dS;
				dW.Scale = dW.Scale + Vector3.new(dX * dS, dX * dS, dX * dS)
			end;
			dV:Destroy()
		end))
	end;
	function Eviscerate(dY)
		if dY.Name ~= char then
			local dZ = IT("BodyGyro", dY.Head)
			dZ.CFrame = dZ.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local aF = IT("BoolValue", dY)
			aF.Name = "IsHit"
			local d_ = coroutine.wrap(function()
				dY:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				target = nil;
				coroutine.resume(coroutine.create(function()
					for b, v in pairs(dY:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end;
						if v:IsA("Humanoid") then
							v:Destroy()
						end;
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end;
						if v:IsA("Model") then
							v:Destroy()
						end;
						if v:IsA("Part") or v:IsA("MeshPart") then
							for U, al in pairs(v:GetChildren()) do
								if al:IsA("Decal") then
									al:Destroy()
								end
							end;
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false;
								local e0 = IT("ParticleEmitter", v)
								e0.LightEmission = 1;
								e0.Texture = "rbxassetid://284205403"
								e0.Color = ColorSequence.new(bT.Color)
								e0.Rate = 150;
								e0.Lifetime = NumberRange.new(1)
								e0.Size = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0.75, 0),
									NumberSequenceKeypoint.new(1, 0, 0)
								})
								e0.Transparency = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0, 0),
									NumberSequenceKeypoint.new(1, 1, 0)
								})
								e0.Speed = NumberRange.new(0, 0)
								e0.VelocitySpread = 30000;
								e0.Rotation = NumberRange.new(-500, 500)
								e0.RotSpeed = NumberRange.new(-500, 500)
								local e1 = IT("BodyPosition", v)
								e1.P = 3000;
								e1.D = 1000;
								e1.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								e1.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
								v.Color = bT.Color;
								coroutine.resume(coroutine.create(function()
									for b = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.08
									end;
									wait(0.5)
									e0.Enabled = false;
									wait(3)
									v:Destroy()
									dY:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			d_()
		end
	end;
	function FindNearestHead(Position, e2, e3)
		if e3 then
			return e2 > e3.Torso.CFrame.p - Position.magnitude
		end;
		local e4 = {}
		for b, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and e2 >= v.Head.Position - Position.magnitude then
				table.insert(e4, v)
			end
		end;
		return e4
	end;
	function Aura(dS, e5, type, aj, dD, dE, dF, dT, aO, e6, dU)
		local type = type;
		local dV = Instance.new("Part", char)
		dV.Anchored = true;
		dV.BrickColor = aO;
		dV.CanCollide = false;
		dV.FormFactor = 3;
		dV.Name = "Ring"
		dV.Material = "Neon"
		dV.Size = Vector3.new(1, 1, 1)
		dV.Transparency = 0;
		dV.TopSurface = 0;
		dV.BottomSurface = 0;
		dV.CFrame = aj;
		dV.CFrame = dV.CFrame + dV.CFrame.lookVector * e6;
		local dW = Instance.new("SpecialMesh", dV)
		dW.MeshType = dU;
		dW.Scale = Vector3.new(dD, dE, dF)
		local dX = 1;
		local e7 = e5;
		if type == "Add" then
			dX = 1 * dT
		elseif type == "Divide" then
			dX = 1 / dT
		end;
		coroutine.resume(coroutine.create(function()
			for b = 0, 10 / dS, 0.1 do
				swait()
				if type == "Add" then
					dX = dX - 0.01 * dT / dS
				elseif type == "Divide" then
					dX = dX - 0.01 / dT * dS
				end;
				e7 = e7 - 0.01 * e5 * dS;
				dV.CFrame = dV.CFrame + dV.CFrame.lookVector * e7 * dS;
				dV.Transparency = dV.Transparency + 0.01 * dS;
				dW.Scale = dW.Scale + Vector3.new(dX * dS, dX * dS, 0)
			end;
			dV:Destroy()
		end))
	end;
	function SoulSteal(dY)
		if dY.Name ~= char then
			local dZ = IT("BodyGyro", dY.Head)
			dZ.CFrame = dZ.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local aF = IT("BoolValue", dY)
			aF.Name = "IsHit"
			local e8 = dY:FindFirstChild'Head' or dY:FindFirstChild'Torso' or dY:FindFirstChild'UpperTorso' or dY:FindFirstChild'LowerTorso' or dY:FindFirstChild'HumanoidRootPart'
			local e9 = coroutine.wrap(function()
				local ea = Instance.new("Part", dY)
				ea.Size = Vector3.new(1, 1, 1)
				ea.CanCollide = false;
				ea.Anchored = false;
				ea.Position = e8.Position;
				ea.Transparency = 1;
				local e0 = IT("ParticleEmitter", ea)
				e0.LightEmission = 1;
				e0.Texture = "rbxassetid://569507414"
				e0.Color = ColorSequence.new(bT.Color)
				e0.Rate = 250;
				e0.Lifetime = NumberRange.new(1.6)
				e0.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				e0.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0, 0),
					NumberSequenceKeypoint.new(1, 1, 0)
				})
				e0.Speed = NumberRange.new(0, 0)
				e0.VelocitySpread = 30000;
				e0.Rotation = NumberRange.new(-360, 360)
				e0.RotSpeed = NumberRange.new(-360, 360)
				local e1 = IT("BodyPosition", ea)
				e1.P = 3000;
				e1.D = 1000;
				e1.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
				e1.position = e8.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
				wait(1.6)
				ea.Touched:connect(function(eb)
					if eb.Parent == char then
						ea:Destroy()
					end
				end)
				wait(1.2)
				while ea do
					swait()
					e0.Color = ColorSequence.new(bT.Color)
					e1.Position = bL.Position
				end
			end)
			e9()
		end
	end;
	function CreatePart(cZ, c_, d0, d1, d2, d3, d4)
		local Part = cO("Part"){
			Parent = cZ,
			Reflectance = d0,
			Transparency = d1,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(d2)),
			Name = d3,
			Size = d4,
			Material = c_
		}
		RemoveOutlines(Part)
		return Part
	end;
	function CreateMesh(Mesh, Part, d5, d6, d7, d8)
		local d9 = cO(Mesh){
			Parent = Part,
			Offset = d7,
			Scale = d8
		}
		if Mesh == "SpecialMesh" then
			d9.MeshType = d5;
			d9.MeshId = d6
		end;
		return d9
	end;
	function BlockEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay, dJ)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("BlockMesh", dK, "", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		if dJ == 1 or dJ == nil then
			table.insert(Effects, {
				dK,
				"Block1",
				delay,
				dG,
				dH,
				dI,
				msh
			})
		elseif dJ == 2 then
			table.insert(Effects, {
				dK,
				"Block2",
				delay,
				dG,
				dH,
				dI,
				msh
			})
		end
	end;
	function SphereEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("SpecialMesh", dK, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function RingEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", vt(.5, .5, .5))
		dK.Anchored = true;
		dK.CFrame = dC;
		msh = CreateMesh("SpecialMesh", dK, "FileMesh", "http://www.roblox.com/asset/?id=3270017", vt(0, 0, 0), vt(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 2)
		coroutine.resume(coroutine.create(function(Part, Mesh, ac)
			for b = 0, 1, delay do
				swait()
				Part.Transparency = b;
				Mesh.Scale = Mesh.Scale + vt(dG, dH, dI)
			end;
			Part.Parent = nil
		end), dK, msh, (math.random(0, 1) + math.random()) / 5)
	end;
	function CylinderEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "SmoothPlastic", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("CylinderMesh", dK, "", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function WaveEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("SpecialMesh", dK, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function SpecialEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("SpecialMesh", dK, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function MoonEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("SpecialMesh", dK, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function HeadEffect(dB, dC, dD, dE, dF, dG, dH, dI, delay)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new())
		dK.Anchored = true;
		dK.CFrame = dC;
		local msh = CreateMesh("SpecialMesh", dK, "Head", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Cylinder",
			delay,
			dG,
			dH,
			dI,
			msh
		})
	end;
	function BreakEffect(dB, dC, dD, dE, dF)
		local dK = CreatePart(workspace, "Neon", 0, 0, dB, "Effect", Vector3.new(0.5, 0.5, 0.5))
		dK.Anchored = true;
		dK.CFrame = dC * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		local msh = CreateMesh("SpecialMesh", dK, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(dD, dE, dF))
		local ac = math.random(10, 50) / 1000;
		game:GetService("Debris"):AddItem(dK, 10)
		table.insert(Effects, {
			dK,
			"Shatter",
			ac,
			dK.CFrame,
			math.random() - math.random(),
			0,
			math.random(50, 100) / 100
		})
	end;
	so = function(Z, de, df, dg)
		coroutine.resume(coroutine.create(function()
			local ec = Instance.new("Sound", de or workspace)
			ec.Volume = df;
			ec.Pitch = dg or 1;
			ec.SoundId = Z;
			ec:play()
			game:GetService("Debris"):AddItem(ec, 8)
		end))
	end;
	function FaceMouse()
		local Cam = workspace.CurrentCamera;
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end;
	function Cso(ed, ee, ef, eg)
		local eh = nil;
		coroutine.resume(coroutine.create(function()
			eh = IT("Sound", ee)
			eh.Volume = ef;
			eh.Pitch = eg;
			eh.SoundId = "http://www.roblox.com/asset/?id=" .. ed;
			swait()
			eh:play()
			game:GetService("Debris"):AddItem(eh, 10)
		end))
		return eh
	end;
	function CameraEnshaking(ei, ej)
		coroutine.resume(coroutine.create(function()
			local ek = 1 * ej;
			local el = 0.01 * ej;
			for b = 0, ei, 0.1 do
				swait()
				ek = ek - 0.05 * ej / ei;
				el = el - 5.0E-4 * ej / ei;
				hum.CameraOffset = Vector3.new(Rad(Mrandom(-ek, ek)), Rad(Mrandom(-ek, ek)), Rad(Mrandom(-ek, ek)))
				cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-ek, ek)), Rad(Mrandom(-ek, ek)), Rad(Mrandom(-ek, ek))) * Euler(Rad(Mrandom(-ek, ek)) * el, Rad(Mrandom(-ek, ek)) * el, Rad(Mrandom(-ek, ek)) * el)
			end;
			hum.CameraOffset = Vector3.new(0, 0, 0)
		end))
	end;
	local em = 1;
	if em ~= 1 then
		bJ.Size = bJ.Size * em;
		bL.Size = bL.Size * em;
		bI.Size = bI.Size * em;
		bM.Size = bM.Size * em;
		bN.Size = bN.Size * em;
		bO.Size = bO.Size * em;
		bP.Size = bP.Size * em;
		bK.Parent = bJ;
		bQ.Parent = bL;
		RW.Parent = bL;
		LW.Parent = bL;
		RH.Parent = bL;
		LH.Parent = bL;
		bK.C0 = RootCF * CF(0 * em, 0 * em, 0 * em) * angles(Rad(0), Rad(0), Rad(0))
		bK.C1 = RootCF * CF(0 * em, 0 * em, 0 * em) * angles(Rad(0), Rad(0), Rad(0))
		bQ.C0 = necko * CF(0 * em, 0 * em, 0 + 1 * em - 1) * angles(Rad(0), Rad(0), Rad(0))
		bQ.C1 = CF(0 * em, -0.5 * em, 0 * em) * angles(Rad(-90), Rad(0), Rad(180))
		RW.C0 = CF(1.5 * em, 0.5 * em, 0 * em) * angles(Rad(0), Rad(0), Rad(0))
		LW.C0 = CF(-1.5 * em, 0.5 * em, 0 * em) * angles(Rad(0), Rad(0), Rad(0))
		RH.C0 = CF(1 * em, -1 * em, 0 * em) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C0 = CF(-1 * em, -1 * em, 0 * em) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		RH.C1 = CF(0.5 * em, 1 * em, 0 * em) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C1 = CF(-0.5 * em, 1 * em, 0 * em) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
	end;
	local en = 900817147;
	local eo = 0;
	local ep = Instance.new("Sound", bL)
	ep.Volume = 0.7;
	ep.Looped = true;
	ep.Pitch = 1;
	local eq = false;
	local er = 0;
	local change = 1;
	local aF = 0;
	local es = 0;
	local et = 0.4;
	local sine = 0;
	local eu = 1;
	local ev = 1;
	local ew = false;
	local ex = CFrame.fromEulerAnglesXYZ;
	local ey = false;
	hum.WalkSpeed = 8;
	hum.JumpPower = 57;
	local ez = hum.Animator;
	local eA = char.Animate;
	eA.Parent = nil;
	ez.Parent = nil;
	function attackone()
		attack = true;
		for b = 0, 1.35, 0.1 do
			swait()
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4 - 2 * b), math.rad(4 + 2 * b), math.rad(-40 - 11 * b)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40 + 11 * b)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90 + 4 * b), math.rad(-43), math.rad(16 + 6 * b)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * bR * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * bS * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end;
		so("http://roblox.com/asset/?id=1340545854", bM, 1, math.random(0.7, 1))
		con5 = bM.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					so("http://roblox.com/asset/?id=636494529", bM, 2, 1)
					RingEffect(BrickColor.new("White"), bM.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("White"), bM.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("White"), bM.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8)), 0.24)
						end
					end))
					wait(0.34)
					ew = false
				end
			end
		end)
		for b = 0, 1.12, 0.1 do
			swait()
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * bR * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * bS * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
		end;
		con5:Disconnect()
		attack = false
	end;
	function attacktwo()
		attack = true;
		for b = 0, 1.35, 0.1 do
			swait()
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * bR * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end;
		so("http://roblox.com/asset/?id=1340545854", bN, 1, math.random(0.7, 1))
		con5 = bN.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					so("http://roblox.com/asset/?id=636494529", bN, 2, 1)
					RingEffect(BrickColor.new("White"), bN.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("White"), bN.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("White"), bN.CFrame * CFrame.new(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8)), 0.24)
						end
					end))
					wait(0.34)
					ew = false
				end
			end
		end)
		for b = 0, 1.12, 0.1 do
			swait()
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * bR * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * bS * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
		end;
		con5:Disconnect()
		attack = false
	end;
	function attackthree()
		attack = true;
		for b = 0, 1.14, 0.1 do
			swait()
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * bR * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
		end;
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					so("http://roblox.com/asset/?id=636494529", bP, 2, 1)
					RingEffect(BrickColor.new("White"), bP.CFrame * CF(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("White"), bP.CFrame * CF(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("White"), bP.CFrame * CF(0, -1, 0) * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8)), 0.24)
						end
					end))
					wait(0.34)
					ew = false
				end
			end
		end)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for b = 0, 9.14, 0.3 do
			swait()
			BlockEffect(BrickColor.new("White"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0 - 54 * b)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-64 - 7 * b), math.rad(0), math.rad(0 - 9 * b)), 0.35)
		end;
		attack = false;
		con5:disconnect()
	end;
	function attackfour()
		attack = true;
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), bJ.CFrame * CFrame.new(0, -1, 0) * ex(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for b = 0, 5.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24 + 4 * b), math.rad(0), math.rad(0)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0 + 11 * b), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0 - 6 * b), math.rad(0), math.rad(36 + 4 * b)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0 - 6 * b), math.rad(0), math.rad(-36 - 4 * b)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * bR * angles(math.rad(0), math.rad(0), math.rad(-28 + 4 * b)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * bS * angles(math.rad(0), math.rad(0), math.rad(-34 - 4 * b)), 0.2)
		end;
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		local eB = Instance.new("BodyVelocity")
		eB.velocity = vt(0, 25, 0)
		eB.P = 8000;
		eB.maxForce = Vector3.new(math.huge, math.huge, math.huge)
		eB.Parent = bJ;
		game:GetService("Debris"):AddItem(eB, 0.7)
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					coroutine.resume(coroutine.create(function()
						for b = 0, 1.5, 0.1 do
							swait()
							eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.6, -1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529", bO, 2, 1)
					RingEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75 * 1.8, 0.75 * 1.8), math.random(-0.75 * 1.8, 0.75 * 1.8), math.random(-0.75 * 1.8, 0.75 * 1.8)), 0.44)
						end
					end))
					wait(0.14)
					ew = false
				end
			end
		end)
		for b = 0, 5.11, 0.15 do
			swait()
			BlockEffect(BrickColor.new("White"), bO.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, 0.1 + 0.2 * b) * angles(math.rad(-10 - 80 * b), math.rad(0), math.rad(0)), 0.42)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * bR * angles(math.rad(0), math.rad(0), math.rad(20 + 10 * b)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * bS * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end;
		attack = false;
		con5:disconnect()
	end;
	local eC = false;
	function quickkick()
		attack = true;
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					coroutine.resume(coroutine.create(function()
						for b = 0, 1.5, 0.1 do
							swait()
							eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.3, -1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529", bO, 2, 1)
					RingEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8 * 1.8, 0.8 * 1.8), math.random(-0.8 * 1.8, 0.8 * 1.8), math.random(-0.8 * 1.8, 0.8 * 1.8)), 0.44)
						end
					end))
					wait(0.08)
					ew = false
				end
			end
		end)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for b = 0, 11.14, 0.3 do
			swait()
			bJ.Velocity = bJ.CFrame.lookVector * 30;
			BlockEffect(BrickColor.new("White"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21 - 30 * b), math.rad(8 + 10 * b), math.rad(0 - 90 * b)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-64 - 2 * b), math.rad(0), math.rad(0 - 9 * b)), 0.35)
		end;
		attack = false;
		con5:disconnect()
	end;
	function Taunt()
		attack = true;
		hum.WalkSpeed = 0;
		Cso("1535995570", bI, 8.45, 1)
		for b = 0, 8.2, 0.1 do
			swait()
			hum.WalkSpeed = 0;
			bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.1 + 0.1 * em * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
			RH.C0 = clerp(RH.C0, CF(1 * em, -0.9 - 0.1 * Cos(sine / 12) * em, 0 * em) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			LH.C0 = clerp(LH.C0, CF(-1 * em, -0.9 - 0.1 * Cos(sine / 12) * em, 0 * em) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.1 * em, 0.5 + 0.05 * Sin(sine / 12) * em, -0.5 * em) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1 * em, 0.1 + 0.05 * Sin(sine / 12) * em, -0.5 * em) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
		end;
		attack = false;
		hum.WalkSpeed = 8
	end;
	function Hyperkickcombo()
		attack = true;
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), bJ.CFrame * CFrame.new(0, -1, 0) * ex(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for b = 0, 7.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * bR * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * bS * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end;
		local eD = Cso("292536356", bL, 10, 1)
		for b = 0, 7.14, 0.1 do
			swait()
			hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
			Aura(5, 0.15, "Add", bJ.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
			WaveEffect(BrickColor.new("Lime green"), bJ.CFrame * CFrame.new(0, -6, 0) * ex(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
			SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
			SphereEffect(BrickColor.new("Lime green"), bP.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * bR * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * bS * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end;
		eD.Playing = false;
		so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		SphereEffect(BrickColor.new("Lime green"), bL.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 38, 38, 38, 0.08)
		local eB = Instance.new("BodyVelocity")
		eB.velocity = vt(0, 27, 0)
		eB.P = 11000;
		eB.maxForce = Vector3.new(math.huge, math.huge, math.huge)
		eB.Parent = bJ;
		game:GetService("Debris"):AddItem(eB, 1.24)
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					coroutine.resume(coroutine.create(function()
						for b = 0, 1.5, 0.1 do
							swait()
							eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 3.4, -1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529", bO, 2, 1.6)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
						end
					end))
					wait(0.09)
					ew = false
				end
			end
		end)
		for b = 0, 9.11, 0.2 do
			swait()
			BlockEffect(BrickColor.new("Lime green"), bO.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, 0.1 + 0.12 * b) * angles(math.rad(-10 - 95 * b), math.rad(0), math.rad(0)), 0.42)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * bR * angles(math.rad(0), math.rad(0), math.rad(20 + 10 * b)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * bS * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end;
		con5:disconnect()
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					coroutine.resume(coroutine.create(function()
						for b = 0, 1.5, 0.1 do
							swait()
							eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.1, -1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529", bO, 2, 1.6)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
						end
					end))
					wait(0.08)
					ew = false
				end
			end
		end)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for b = 0, 9.14, 0.3 do
			swait()
			bJ.Velocity = bJ.CFrame.lookVector * 20;
			BlockEffect(BrickColor.new("Lime green"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0 - 54 * b)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-64 - 7 * b), math.rad(0), math.rad(0 - 9 * b)), 0.35)
		end;
		con5:disconnect()
		con5 = hum.Touched:connect(function(eb)
			if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if ew == false then
					ew = true;
					coroutine.resume(coroutine.create(function()
						for b = 0, 1.5, 0.1 do
							swait()
							eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.1, -1.8)
						end
					end))
					so("http://roblox.com/asset/?id=636494529", bO, 2, 1.6)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
					SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
					coroutine.resume(coroutine.create(function()
						for b = 0, 1, 0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
						end
					end))
					wait(0.05)
					ew = false
				end
			end
		end)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for b = 0, 15.14, 0.32 do
			swait()
			bJ.Velocity = bJ.CFrame.lookVector * 20;
			BlockEffect(BrickColor.new("Lime green"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21 - 50 * b), math.rad(8 + 20 * b), math.rad(0 - 90 * b)), 0.35)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-64 - 2 * b), math.rad(0), math.rad(0 - 4 * b)), 0.35)
		end;
		attack = false;
		con5:disconnect()
	end;
	local eE = false;
	function Galekicks()
		attack = true;
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		for b = 0, 1.65, 0.1 do
			swait()
			bJ.Velocity = bJ.CFrame.lookVector * 0;
			SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
			bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
			bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, .62, -0.3) * bR * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
		end;
		for b = 1, 17 do
			con5 = hum.Touched:connect(function(eb)
				if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if ew == false then
						ew = true;
						coroutine.resume(coroutine.create(function()
							for b = 0, 1.5, 0.1 do
								swait()
								eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.1, -1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529", bO, 2, 1.6)
						RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
						RingEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
						SphereEffect(BrickColor.new("Lime green"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
						coroutine.resume(coroutine.create(function()
							for b = 0, 1, 0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
							end
						end))
						wait(0.05)
						ew = false
					end
				end
			end)
			for b = 0, .1, 0.2 do
				swait()
				BlockEffect(BrickColor.new("Lime green"), bO.CFrame * CF(0, -1, 0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
				bJ.Velocity = bJ.CFrame.lookVector * 10;
				bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
				bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6, 0) * bR * angles(math.rad(math.random(-100, -10)), math.rad(0), math.rad(2)), 0.7)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
			end;
			so("http://roblox.com/asset/?id=1340545854", bO, 1, math.random(0.7, 1))
			for b = 0, 0.4, 0.2 do
				swait()
				bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62, -0.3) * bR * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end;
			con5:disconnect()
		end;
		u = mouse.KeyDown:connect(function(aE)
			if aE == 'r' and bV >= 150 then
				eE = true;
				SphereEffect(BrickColor.new("Really red"), bL.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 15, 15, 15, 0.04)
			end
		end)
		wait(0.3)
		if eE == true then
			bV = 0;
			wait(0.1)
			for b = 0, 1.65, 0.1 do
				swait()
				bJ.Velocity = bJ.CFrame.lookVector * 0;
				SphereEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
				bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62, -0.3) * bR * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end;
			so("http://roblox.com/asset/?id=146094803", bI, 1, 1.2)
			for b = 1, 65 do
				con5 = hum.Touched:connect(function(eb)
					if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if ew == false then
							ew = true;
							coroutine.resume(coroutine.create(function()
								for b = 0, 1.5, 0.1 do
									swait()
									eb.Parent.Head.CFrame = bJ.CFrame * CFrame.new(0, 1.1, -1.8)
								end
							end))
							so("http://roblox.com/asset/?id=636494529", bO, 2, 1.6)
							RingEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
							RingEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
							SphereEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
							coroutine.resume(coroutine.create(function()
								for b = 0, 1, 0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
								end
							end))
							wait(0.05)
							ew = false
						end
					end
				end)
				for b = 0, .03, 0.1 do
					swait()
					BlockEffect(BrickColor.new("Really red"), bO.CFrame * CF(0, -1, 0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
					bJ.Velocity = bJ.CFrame.lookVector * 10;
					bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.6, 0) * bR * angles(math.rad(math.random(-100, -10)), math.rad(0), math.rad(2)), 0.7)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
				end;
				so("http://roblox.com/asset/?id=1340545854", bO, 1, math.random(0.7, 1))
				for b = 0, 0.07, 0.1 do
					swait()
					bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62, -0.3) * bR * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end;
				con5:disconnect()
			end;
			for b = 0, 1.65, 0.1 do
				swait()
				bJ.Velocity = bJ.CFrame.lookVector * 0;
				SphereEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)), 1, 5, 1, .05, 4, .05, 0.03)
				bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62, -0.3) * bR * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end;
			con5 = hum.Touched:connect(function(eb)
				if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if ew == false then
						ew = true;
						coroutine.resume(coroutine.create(function()
							for b = 0, 1.5, 0.1 do
								swait()
							end
						end))
						so("http://roblox.com/asset/?id=636494529", bO, 2, .63)
						RingEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
						RingEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, .2, 2, .2, 0.06)
						SphereEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 3, 3, 3, 0.06)
						coroutine.resume(coroutine.create(function()
							for b = 0, 1, 0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8), math.random(-0.55 * 1.8, 0.55 * 1.8)), 0.34)
							end
						end))
						wait(0.05)
						ew = false
					end
				end
			end)
			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
			SphereEffect(BrickColor.new("Really red"), bO.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 38, 38, 38, 0.08)
			for b = 0, 2, 0.1 do
				swait()
				bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6, 0.2) * bR * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * bS * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end;
			SphereEffect(BrickColor.new("Really red"), bL.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 8, 8, 8, 0.04)
			wait(0.25)
			con5:Disconnect()
			con5 = hum.Touched:connect(function(eb)
				if eb.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if ew == false then
						ew = true;
						so("http://roblox.com/asset/?id=565207203", bP, 7, 0.63)
						RingEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 2.2, 6, 2.2, 0.04)
						RingEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 2.2, 6, 2.2, 0.04)
						SphereEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 8, 8, 8, 0.04)
						SpecialEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 8, 8, 8, 0.04)
						SphereEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 5, 18, 5, 0.04)
						WaveEffect(BrickColor.new("Really red"), bP.CFrame * angles(math.random(-360, 360), math.random(-360, 360), math.random(-360, 360)), 1, 5, 1, 1.5, 16, 1.5, 0.04)
						coroutine.resume(coroutine.create(function()
							for b = 0, 1, 0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8), math.random(-0.35 * 1.8, 0.35 * 1.8)), 0.24)
							end
						end))
						wait(0.06)
						ew = false
					end
				end
			end)
			coroutine.resume(coroutine.create(function()
				while eE == true do
					swait()
					bJ.CFrame = bJ.CFrame * CFrame.new(math.random(-3, 3), math.random(-2, 2), math.random(-3, 3))
				end
			end))
			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for b = 1, 3 do
				for b = 0, 9.14, 0.45 do
					swait()
					bJ.Velocity = bJ.CFrame.lookVector * 30;
					BlockEffect(BrickColor.new("Really red"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0 - 94 * b)), 0.35)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-64 - 7 * b), math.rad(0), math.rad(0 - 9 * b)), 0.35)
				end
			end;
			for b = 1, 3 do
				for b = 0, 11.14, 0.45 do
					swait()
					bJ.Velocity = bJ.CFrame.lookVector * 30;
					BlockEffect(BrickColor.new("Really red"), bP.CFrame * CF(0, -1, 0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					bK.C0 = clerp(bK.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21 - 30 * b), math.rad(8 + 10 * b), math.rad(0 - 110 * b)), 0.35)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * bR * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * bS * angles(math.rad(-34 - 2 * b), math.rad(0), math.rad(0 - 9 * b)), 0.35)
				end
			end;
			so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
			con5:disconnect()
		end;
		attack = false;
		eE = false;
		u:disconnect()
	end;
	mouse.KeyDown:connect(function(aE)
		if string.byte(aE) == 48 then
			Swing = 2;
			hum.WalkSpeed = 24.82
		end
	end)
	mouse.KeyUp:connect(function(aE)
		if string.byte(aE) == 48 then
			Swing = 1;
			hum.WalkSpeed = 8
		end
	end)
	mouse.Button1Down:connect(function()
		if attack == false then
			if ev == 1 then
				attack = true;
				ev = 2;
				attackone()
			elseif ev == 2 then
				attack = true;
				ev = 3;
				attacktwo()
			elseif ev == 3 then
				attack = true;
				ev = 4;
				attackthree()
			elseif ev == 4 then
				attack = true;
				ev = 1;
				attackfour()
			end
		end
	end)
	mouse.KeyDown:connect(function(aE)
		if aE == 'e' and attack == false and ey == true and eC == false then
			quickkick()
			eC = true;
			coroutine.resume(coroutine.create(function()
				wait(2)
				eC = false
			end))
		end
	end)
	mouse.KeyDown:connect(function(aE)
		if attack == false then
			if aE == 't' then
				Taunt()
			elseif aE == 'f' then
				Hyperkickcombo()
			elseif aE == 'r' then
				Galekicks()
			end
		end
	end)
	print("By Makhail07 and KillerDarkness0105")
	print("Basic Animations by Makhail07")
	print("Attack Animations by KillerDarkness0105")
	print("This is pretty much our final script together")
	print("--------------------------------")
	print("Attacks")
	print("E in air: Quick Kicks")
	print("Left Mouse: 4 click combo")
	print("F: Hyper Kicks")
	print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
	print("--------------------------------")
	while true do
		swait()
		sine = sine + change;
		local eF = bJ.Velocity * Vector3.new(1, 0, 1).magnitude;
		local eG = bJ.Velocity.y;
		hitfloor, posfloor = rayCast(bJ.Position, CFrame.new(bJ.Position, bJ.Position - Vector3.new(0, 1, 0)).lookVector, 4 * em, char)
		if hitfloor == nil then
			ey = true
		else
			ey = false
		end;
		if eq == true or eq == false then
			if attack == false then
				er = er + 1
			else
				er = 0
			end;
			if 1 < bJ.Velocity.y and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0, 0, 0), 0.15)
					bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.1 + 0.1 * Cos(sine / 20) * em) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
					bQ.C0 = clerp(bQ.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * em, -.2 - 0.1 * Cos(sine / 20) * em, -.3 * em) * bR * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1 * em, -.9 - 0.1 * Cos(sine / 20), -.5 * em) * bS * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5 * em, 0.5 + 0.02 * Sin(sine / 20) * em, 0 * em) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5 * em, 0.5 + 0.02 * Sin(sine / 20) * em, 0 * em) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif -1 > bJ.Velocity.y and hitfloor == nil then
				Anim = "Fall"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0, 0, 0), 0.15)
					bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.1 + 0.1 * Cos(sine / 20) * em) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
					bQ.C0 = clerp(bQ.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * em, -1 - 0.1 * Cos(sine / 20) * em, -.3 * em) * bR * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1 * em, -.8 - 0.1 * Cos(sine / 20) * em, -.3 * em) * bS * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5 * em, 0.5 + 0.02 * Sin(sine / 20) * em, 0 * em) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5 * em, 0.5 + 0.02 * Sin(sine / 20) * em, 0 * em) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif eF < 1 and hitfloor ~= nil then
				Anim = "Idle"
				change = 1;
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0, 0, 0), 0.15)
					bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.1 + 0.1 * em * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1 * em, -0.9 - 0.1 * Cos(sine / 12) * em, 0 * em) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1 * em, -0.9 - 0.1 * Cos(sine / 12) * em, -0.2 * em) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5 * em, 0.2 + 0.05 * Sin(sine / 12) * em, 0 * em) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.3 * em, 0.2 + 0.05 * Sin(sine / 12) * em, -0.5 * em) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				end
			elseif eF > 2 and eF < 22 and hitfloor ~= nil then
				Anim = "Walk"
				change = 1;
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0, 0, 0), 0.15)
					bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7 * em) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - bJ.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(-1), Rad(0), Rad(0) - bI.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1 * em, -0.8 - 0.5 * Cos(sine / 7) / 2 * em, 0.6 * Cos(sine / 7) / 2 * em) * angles(Rad(-15 - 15 * Cos(sine / 7)) - bO.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1 * em, -0.8 + 0.5 * Cos(sine / 7) / 2 * em, -0.6 * Cos(sine / 7) / 2 * em) * angles(Rad(-15 + 15 * Cos(sine / 7)) + bP.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5 * em, 0.5 + 0.05 * Sin(sine / 7) * em, 0 * em) * angles(Rad(56) * Cos(sine / 7), Rad(10 * Cos(sine / 7)), Rad(6) - bM.RotVelocity.Y / 75), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5 * em, 0.5 + 0.05 * Sin(sine / 7) * em, 0 * em) * angles(Rad(-56) * Cos(sine / 7), Rad(10 * Cos(sine / 7)), Rad(-6) + bN.RotVelocity.Y / 75), 0.1)
				end
			elseif eF >= 22 and hitfloor ~= nil then
				Anim = "Sprint"
				change = 1.35;
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0, 0, 0), 0.15)
					bK.C0 = clerp(bK.C0, RootCF * CF(0 * em, 0 * em, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7 * em) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - bJ.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
					bL.Neck.C0 = clerp(bL.Neck.C0, necko * CF(0, 0, 0 + 1 * em - 1) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - bI.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1 * em, -0.925 - 0.5 * Cos(sine / 7) / 2 * em, 0.7 * Cos(sine / 7) / 2 * em) * angles(Rad(-15 - 55 * Cos(sine / 7)) - bO.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1 * em, -0.925 + 0.5 * Cos(sine / 7) / 2 * em, -0.7 * Cos(sine / 7) / 2 * em) * angles(Rad(-15 + 55 * Cos(sine / 7)) + bP.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5 * em, 0.5 + 0.05 * Sin(sine / 30) * em, 0.34 * Cos(sine / 7 * em)) * angles(Rad(-65), Rad(0), Rad(13) - bM.RotVelocity.Y / 75), 0.15)
					LW.C0 = clerp(LW.C0, CF(-1.5 * em, 0.5 + 0.05 * Sin(sine / 30) * em, -0.34 * Cos(sine / 7 * em)) * angles(Rad(-65), Rad(0), Rad(-13) + bN.RotVelocity.Y / 75), 0.15)
				end
			end
		end;
		ep.SoundId = "rbxassetid://" .. en;
		ep.Looped = true;
		ep.Pitch = 1;
		ep.Volume = 0.7;
		ep.Parent = bL;
		ep:Resume()
		if 0 < #Effects then
			for eH = 1, #Effects do
				if Effects[eH] ~= nil then
					local eI = Effects[eH]
					if eI ~= nil then
						local Part = eI[1]
						local eJ = eI[2]
						local eK = eI[3]
						local eL = eI[4]
						local eM = eI[5]
						local eN = eI[6]
						if 1 >= eI[1].Transparency then
							if eI[2] == "Block1" then
								eI[1].CFrame = eI[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
								local Mesh = eI[1].Mesh;
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[4], eI[5], eI[6])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Block2" then
								eI[1].CFrame = eI[1].CFrame + Vector3.new(0, 0, 0)
								local Mesh = eI[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[4], eI[5], eI[6])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Block3" then
								eI[1].CFrame = eI[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
								local Mesh = eI[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[4], eI[5], eI[6])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Cylinder" then
								local Mesh = eI[1].Mesh;
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[4], eI[5], eI[6])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Blood" then
								local Mesh = eI[7]
								eI[1].CFrame = eI[1].CFrame * Vector3.new(0, 0.5, 0)
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[4], eI[5], eI[6])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Elec" then
								local Mesh = eI[1].Mesh;
								Mesh.Scale = Mesh.Scale + Vector3.new(eI[7], eI[8], eI[9])
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Disappear" then
								eI[1].Transparency = eI[1].Transparency + eI[3]
							elseif eI[2] == "Shatter" then
								eI[1].Transparency = eI[1].Transparency + eI[3]
								eI[4] = eI[4] * CFrame.new(0, eI[7], 0)
								eI[1].CFrame = eI[4] * CFrame.fromEulerAnglesXYZ(eI[6], 0, 0)
								eI[6] = eI[6] + eI[5]
							end
						else
							Part.Parent = nil;
							table.remove(Effects, eH)
						end
					end
				end
			end
		end
	end
end)
c:CreateButton("Trap Rifle", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	function LoadLibrary(a)
		--return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
		return loadstring(game:HttpGet("https://raw.githubusercontent.com/inceldom/leaks/main/loadlib",true))()
	end;
	wait(1 / 60)
	Effects = {}
	local Player = game:service'Players'.localPlayer;
	local eO = Player.Character.Shiba;
	local Humanoid = eO:FindFirstChildOfClass("Humanoid")
	local eP = Player:GetMouse()
	local LeftArm = eO["Left Arm"]
	local RightArm = eO["Right Arm"]
	local LeftLeg = eO["Left Leg"]
	local RightLeg = eO["Right Leg"]
	local Head = eO.Head;
	local Torso = eO.Torso;
	local eQ = workspace.CurrentCamera;
	local RootPart = eO.HumanoidRootPart;
	local RootJoint = RootPart.RootJoint;
	local attack = false;
	local Anim = 'Idle'
	local ev = 1;
	local eR = false;
	local eS = true;
	local eT = nil;
	local eU = RootPart.Velocity * Vector3.new(1, 0, 1).magnitude;
	local eV = RootPart.Velocity.y;
	local sine = 0;
	local change = 1;
	local eW = 0;
	local cO = LoadLibrary("RbxUtility").Create;
	local eX = game:GetService("Debris")
	Humanoid.WalkSpeed = 16;
	Humanoid.Animator.Parent = nil;
	eO.Animate.Parent = nil;
	local eY = function(ag, ah, eZ, e_)
		local cs = cO('Motor'){
			Parent = ag,
			Part0 = ag,
			Part1 = ah,
			C0 = eZ,
			C1 = e_
		}
		return cs
	end;
	function clerp(a, j, t)
		return a:lerp(j, t)
	end;
	RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	local RW = eY(Torso, RightArm, CFrame.new(1.5, 0, 0), CFrame.new(0, 0, 0))
	local LW = eY(Torso, LeftArm, CFrame.new(-1.5, 0, 0), CFrame.new(0, 0, 0))
	local RH = eY(Torso, RightLeg, CFrame.new(.5, -2, 0), CFrame.new(0, 0, 0))
	local LH = eY(Torso, LeftLeg, CFrame.new(-.5, -2, 0), CFrame.new(0, 0, 0))
	RootJoint.C1 = CFrame.new(0, 0, 0)
	RootJoint.C0 = CFrame.new(0, 0, 0)
	Torso.Neck.C1 = CFrame.new(0, 0, 0)
	Torso.Neck.C0 = CFrame.new(0, 1.5, 0)
	local f0 = RW.C1;
	local f1 = LW.C1;
	local f2 = RH.C1;
	local f3 = LH.C1;
	local f4 = false;
	function PlayAnimationFromTable(table, f5, f6)
		RootJoint.C0 = clerp(RootJoint.C0, table[1], f5)
		Torso.Neck.C0 = clerp(Torso.Neck.C0, table[2], f5)
		RW.C0 = clerp(RW.C0, table[3], f5)
		LW.C0 = clerp(LW.C0, table[4], f5)
		RH.C0 = clerp(RH.C0, table[5], f5)
		LH.C0 = clerp(LH.C0, table[6], f5)
		if f6 == true then
			if f4 == false then
				f4 = true;
				RootJoint.C1 = RootJoint.C1;
				Torso.Neck.C1 = Torso.Neck.C1;
				RW.C1 = f0;
				LW.C1 = f1;
				RH.C1 = f2;
				LH.C1 = f3
			end
		end
	end;
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")
	frame = 0.03333333333333;
	tf = 0;
	allowframeloss = false;
	tossremainder = false;
	lastframe = tick()
	script.Heartbeat:Fire()
	game:GetService("RunService").Heartbeat:connect(function(am, aG)
		tf = tf + am;
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for b = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end;
				lastframe = tick()
			end;
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	function swait(ac)
		if ac == 0 or ac == nil then
			ArtificialHB.Event:wait()
		else
			for b = 0, ac do
				ArtificialHB.Event:wait()
			end
		end
	end;
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end;
	function so(Z, de, dg, df)
		local ec = Instance.new("Sound", de or workspace)
		if de == eO then
			ec.Parent = eO.Torso
		end;
		ec.Volume = df;
		ec.Pitch = dg or 1;
		ec.SoundId = "rbxassetid://" .. Z;
		ec.PlayOnRemove = true;
		ec:Destroy()
	end;
	New = function(f7, cZ, d3, f8)
		local f7 = Instance.new(f7)
		for f9, fa in pairs(f8 or {}) do
			f7[f9] = fa
		end;
		f7.Parent = cZ;
		f7.Name = d3;
		return f7
	end;
	LuvGun = New("Model", eO, "LuvGun", {})
	Handle = New("Part", LuvGun, "Handaru", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.199999809, 1.10000002, 0.50000006),
		CFrame = CFrame.new(-55.7999725, 3.16094255, -23.6752853, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	HWeld = New("ManualWeld", Handle, "HWeld", {
		Part0 = Handle,
		Part1 = RightArm,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
		C1 = CFrame.new(-0.164215088, -1.07379532, 0.339058399, -1, 0, 0, 0, 0, -1, -0, -1, -0)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -22.25, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.56618547, 1.17111206, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -22.0499992, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.60091519, 1.36807442, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999994278, 0.600000024, 0.600000024),
		CFrame = CFrame.new(-55.7999611, 2.34997582, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),
		C1 = CFrame.new(1.14440918e-05, -0.577195883, 1.39673233, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.700000048, 0.199999988),
		CFrame = CFrame.new(-55.6999779, 4.59997463, -23.2499962, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),
		C1 = CFrame.new(0.0999946594, 1.49102044, 0.168943405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.100000001, 0.800000012),
		CFrame = CFrame.new(-55.849968, 4.39997292, -20.2000103, 0, -1, 0, 0, 0, -1.00000012, 1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, 1, -1, 0, 0, 0, -1, 0),
		C1 = CFrame.new(-0.0499954224, 1.82368135, 3.20732307, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.100000001, 0.199999988),
		CFrame = CFrame.new(-55.7999725, 4.59997463, -23.5499954, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		Scale = Vector3.new(0.200000003, 1, 1),
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),
		C1 = CFrame.new(0, 1.43892598, -0.126499176, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	ShotPt = New("Part", LuvGun, "ShotPt", {
		Transparency = 1,
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999983624, 0.100000001, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 3.84997725, -19.3500118, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines
	})
	Weld = New("ManualWeld", ShotPt, "Weld", {
		Part0 = ShotPt,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.42964172, 4.13991356, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.399998486, 0.400000006, 0.100000001),
		CFrame = CFrame.new(-55.9499664, 3.89997602, -22.4000187, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		Scale = Vector3.new(1.20000005, 1, 1.20000005),
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(-0.149993896, 0.949253559, 1.12756157, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Lily white"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.599999428, 0.800000072, 0.600000024),
		CFrame = CFrame.new(-55.7999611, 2.79997706, -22.4000034, -1, 0, 0, 0, 1.00000012, 0, 0, 0, -1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(0.929412, 0.917647, 0.917647)
	})
	Mesh = New("CylinderMesh", Part, "Mesh", {})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),
		C1 = CFrame.new(1.14440918e-05, -0.134031534, 1.31858826, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		Transparency = 1,
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.600000024, 0.5, 0.600000024),
		CFrame = CFrame.new(-55.7999611, 2.79997706, -22.4000034, -1, 0, 0, 0, 1.00000012, 0, 0, 0, -1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines
	})
	Mesh = New("CylinderMesh", Part, "Mesh", {})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),
		C1 = CFrame.new(1.14440918e-05, -0.134031534, 1.31858826, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.100000001, 0.800000012),
		CFrame = CFrame.new(-55.7499695, 4.39997292, -20.2000103, 0, 1, 0, 0, 0, -1.00000012, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 1, 0, 0, 0, -1, 0),
		C1 = CFrame.new(0.0500030518, 1.82368135, 3.20732307, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.700000048, 0.199999988),
		CFrame = CFrame.new(-55.899971, 4.59997463, -23.2499962, 1, 0, 0, 0, 0, -1.00000012, 0, 1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0),
		C1 = CFrame.new(-0.0999984741, 1.49102044, 0.168943405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.199999422, 0.400000006, 0.600000024),
		CFrame = CFrame.new(-55.7999611, 3.39997506, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),
		C1 = CFrame.new(1.14440918e-05, 0.456851482, 1.21440125, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 1.70000017),
		CFrame = CFrame.new(-55.649971, 3.84997725, -24.8499966, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(0.150001526, 0.474580526, -1.27651405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(3.8999989, 0.400000006, 0.400000006),
		CFrame = CFrame.new(-55.7999687, 3.89997602, -22.0499992, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.01003361, 1.47226334, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(1.90000045, 0.100000001, 0.0999998972),
		CFrame = CFrame.new(-55.5999718, 3.44997501, -21.1500034, 0, 1, 0, 0, 0, 1.00000012, 1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0),
		C1 = CFrame.new(0.200000763, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),
		CFrame = CFrame.new(-55.9499664, 3.84997725, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(-0.149993896, 0.318296194, -2.16284752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.100000001, 1.89999998),
		CFrame = CFrame.new(-55.7999687, 3.44997501, -21.1500034, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.499999911, 0.100000001),
		CFrame = CFrame.new(-55.9499664, 3.54997826, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(-0.149993896, 0.022854805, -2.11075401, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999994278, 0.600000024, 0.600000024),
		CFrame = CFrame.new(-55.7999611, 3.24997807, -22.4000015, 0, 0, -1, 1.00000012, 0, 0, 0, -1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0),
		C1 = CFrame.new(1.14440918e-05, 0.309133291, 1.240448, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),
		CFrame = CFrame.new(-55.9499664, 3.24997902, -25.7500019, 0, 0, -1, 0, -1.00000012, -0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1, 0, -1, -0, -0),
		C1 = CFrame.new(-0.149993896, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),
		CFrame = CFrame.new(-55.649971, 3.24997902, -25.7500019, 0, 0, -1, 0, -1.00000012, -0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, -1, 0, -1, -0, -0),
		C1 = CFrame.new(0.150001526, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.399998367, 0.300000012, 0.400000006),
		CFrame = CFrame.new(-55.7999687, 3.84997725, -19.6000099, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		Scale = Vector3.new(1, 1.20000005, 1),
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.38622999, 3.893713, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.299998373, 0.300000012, 0.400000006),
		CFrame = CFrame.new(-55.7999687, 3.84997702, -19.9500103, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.3254528, 3.5490303, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.499999911, 0.100000001),
		CFrame = CFrame.new(-55.649971, 3.54997826, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(0.150001526, 0.022854805, -2.11075401, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.399999976, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 3.39394569, -22.9842033, 1, 0, 0, 0, 0.939692855, 0.342019945, 0, -0.342019945, 0.939692855),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
		C1 = CFrame.new(3.81469727e-06, 0.349468231, 0.64012146, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Really black"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999983624, 0.300000012, 0.400000006),
		CFrame = CFrame.new(-55.7999687, 3.84997654, -19.4500065, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		Scale = Vector3.new(1.10000002, 1, 1),
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.41227698, 4.04143715, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.100000001, 0.5, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 3.24997902, -23.2000008, -1, 0, 0, 0, 0, 1.00000012, 0, 1.00000012, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0),
		C1 = CFrame.new(3.81469727e-06, 0.170215845, 0.452602386, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.399999797, 0.399999917, 3.89999962),
		CFrame = CFrame.new(-55.7999687, 3.69997907, -22.0500031, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 0.81307435, 1.50698853, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.199999809, 0.0999999121, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 3.24997902, -25.7500019, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, -0.272586584, -2.0586586, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 0.100000001),
		CFrame = CFrame.new(-55.649971, 3.84997725, -25.7500038, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(0.150001526, 0.318296194, -2.16284752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.199998379, 0.200000018, 0.400000006),
		CFrame = CFrame.new(-55.7999687, 3.59997559, -20.0000114, 0, 0, 1, 0, 1.00000012, 0, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Cylinder
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
		C1 = CFrame.new(3.81469727e-06, 1.07056713, 3.54320145, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.0999998078, 0.0999998972, 1.70000017),
		CFrame = CFrame.new(-55.9499702, 3.84997702, -24.8499966, 1, 0, 0, 0, 1, -3.7252903e-07, 0, 3.7252903e-07, 1),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(-0.149997711, 0.474580288, -1.27651405, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.5, 0.300000012, 1.89999998),
		CFrame = CFrame.new(-55.7999687, 3.64997578, -21.1500034, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 0.920113564, 2.40199661, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.5, 0.20000115),
		CFrame = CFrame.new(-55.7999687, 4.16505194, -21.5144958, 1, 0, 0, 0, 0.939692855, 0.342019945, 0, -0.342019945, 0.939692855),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
		C1 = CFrame.new(3.81469727e-06, 1.36407137, 1.95359993, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 2.10000134),
		CFrame = CFrame.new(-55.7999687, 4.39997292, -22.5499954, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.41561127, 0.893039703, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.300000012, 0.20000115),
		CFrame = CFrame.new(-55.7999649, 4.14997578, -23.5, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C1 = CFrame.new(7.62939453e-06, 1.00444555, 0.00087928772, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -21.6500015, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.67037416, 1.76199532, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -21.8499985, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.63564491, 1.56503677, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -22.4499969, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.53145647, 0.974153519, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.49997282, -22.6499939, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.49672723, 0.777194977, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(0.300000012, 0.200000003, 0.100000001),
		CFrame = CFrame.new(-55.7999687, 4.4999733, -22.8499947, 1, 0, 0, 0, 1.00000012, -3.87430191e-07, 0, 3.87430191e-07, 1.00000012),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.4, 0.8)
	})
	Mesh = New("BlockMesh", Part, "Mesh", {
		Scale = Vector3.new(0.800000012, 0.5, 0.800000012)
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 3.7252903e-07, 0, -3.7252903e-07, 1),
		C1 = CFrame.new(3.81469727e-06, 1.46199775, 0.58023262, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	Part = New("Part", LuvGun, "Part", {
		BrickColor = BrickColor.new("Carnation pink"),
		Material = Enum.Material.SmoothPlastic,
		Size = Vector3.new(1.90000045, 0.100000001, 0.0999998972),
		CFrame = CFrame.new(-55.9999657, 3.44997501, -21.1500034, 0, -1, 0, 0, 0, 1.00000012, -1.00000012, 0, 0),
		CanCollide = false,
		BackSurface = Enum.SurfaceType.SmoothNoOutlines,
		BottomSurface = Enum.SurfaceType.SmoothNoOutlines,
		FrontSurface = Enum.SurfaceType.SmoothNoOutlines,
		LeftSurface = Enum.SurfaceType.SmoothNoOutlines,
		RightSurface = Enum.SurfaceType.SmoothNoOutlines,
		TopSurface = Enum.SurfaceType.SmoothNoOutlines,
		Color = Color3.new(1, 0.596078, 0.862745)
	})
	Mesh = New("SpecialMesh", Part, "Mesh", {
		MeshType = Enum.MeshType.Wedge
	})
	Weld = New("ManualWeld", Part, "Weld", {
		Part0 = Part,
		Part1 = Handle,
		C0 = CFrame.new(0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 1, 0),
		C1 = CFrame.new(-0.199993134, 0.723151445, 2.43672752, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849)
	})
	function rayCast(Position, cK, cL, cM)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Position, cK.unit * (cL or 999.999)), cM)
	end;
	function FindNearestTorso(Position, e2, e3)
		if e3 then
			return e3.Head.CFrame.p - Position.magnitude < e2
		end;
		local e4 = {}
		for b, v in pairs(workspace:GetDescendants()) do
			if v:IsA("Model") then
				if v:findFirstChild("Head") then
					if v ~= eO then
						if v.Head.Position - Position.magnitude <= e2 then
							table.insert(e4, v)
						end
					end
				end
			end
		end;
		return e4
	end;
	EffectModel = cO("Model"){
		Parent = eO,
		Name = "Effects"
	}
	game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
	local function af(ag, ah)
		attachment = Instance.new("Attachment", ag)
		attachment.Position = Vector3.new(0.3, -0.7, 0.1)
		attachment.Orientation = Vector3.new(15, -90, -15)
		attachment02 = Instance.new("Attachment", ah)
		lol = Instance.new("AlignPosition", ag)
		lol.Attachment0 = attachment;
		lol.Attachment1 = attachment02;
		lol.MaxForce = math.huge;
		lol.RigidityEnabled = true;
		pog = Instance.new("AlignOrientation", ag)
		pog.Attachment0 = attachment;
		pog.Attachment1 = attachment02;
		pog.Responsiveness = 20;
		pog.RigidityEnabled = true
	end;
	af(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, Handle)
	Effects = {
		Block = function(cf, fb, fc, fd, fe, ff, spin, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = fb;
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.Material = fe;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("BlockMesh", aG)
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd;
					if spin == true then
						aG.CFrame = aG.CFrame * CFrame.Angles(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
					end
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Sphere = function(cf, fb, fc, fd, fe, ff, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = fb;
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.Material = fe;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("SpecialMesh", aG)
			aA.MeshType = "Sphere"
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Cylinder = function(cf, fb, fc, fd, fe, ff, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = fb;
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.Material = fe;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("CylinderMesh", aG)
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Wave = function(cf, fc, fd, ff, spin, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = Vector3.new()
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("SpecialMesh", aG)
			aA.MeshId = "rbxassetid://20329976"
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd;
					aG.CFrame = aG.CFrame * CFrame.Angles(0, math.rad(spin), 0)
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Ring = function(cf, fc, fd, ff, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = Vector3.new()
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("SpecialMesh", aG)
			aA.MeshId = "rbxassetid://3270017"
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Meshed = function(cf, fc, fd, ff, dP, fi, spin, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = Vector3.new()
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.CFrame = cf;
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("SpecialMesh", aG)
			aA.MeshId = dP;
			aA.TextureId = fi;
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd;
					aG.CFrame = aG.CFrame * CFrame.Angles(0, math.rad(spin), 0)
				end;
				aG:Destroy()
			end)()
			return aG
		end,
		Explode = function(cf, fb, fc, fd, fe, ff, fj, fg, fh)
			local aG = Instance.new("Part", EffectModel)
			aG.BrickColor = BrickColor.new(ff)
			aG.Size = fb;
			aG.Anchored = true;
			aG.CanCollide = false;
			aG.Material = fe;
			aG.CFrame = cf * CFrame.Angles(math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)), math.rad(math.random(-360, 360)))
			if fg == true then
				aG.Transparency = 1
			else
				aG.Transparency = 0
			end;
			local aA = Instance.new("SpecialMesh", aG)
			aA.MeshType = "Sphere"
			aA.Scale = fc;
			coroutine.wrap(function()
				for b = 0, 1, fh do
					swait()
					if fg == true then
						aG.Transparency = 1 - b
					else
						aG.Transparency = b
					end;
					aA.Scale = aA.Scale + fd;
					aG.CFrame = aG.CFrame * CFrame.new(0, fj, 0)
				end;
				aG:Destroy()
			end)()
			return aG
		end
	}
	function GetDudesTorso(c)
		local fk = c:findFirstChild("Torso") or c:findFirstChild("UpperTorso")
		if fk ~= nil then
			return fk
		end
	end;
	function BodyVel(part, fl)
		local fm = Instance.new("BodyVelocity", part)
		local fn = 10000000;
		fm.P = fn;
		fm.MaxForce = Vector3.new(fn, fn, fn)
		fm.Velocity = fl;
		eX:AddItem(fm, .2)
	end;
	function MagnitudeDmg(de, fo)
	end;
	local fp = Instance.new("Sound", Head)
	fp.Name = "mus"
	fp.SoundId = "rbxassetid://1131624146"
	fp.Looped = true;
	fp.Volume = 1;
	fp:Play()
	zhold = false;
	function shoot()
		attack = true;
		for b = 0, 1, .3 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
				CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
				CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
				CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
				CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
				CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782)
			}, .4, false)
		end;
		Humanoid.WalkSpeed = 2;
		local fq = Instance.new("Part", eO)
		fq.Size = Vector3.new(0, 0, 0)
		fq.Anchored = true;
		fq.CanCollide = false;
		fq.Transparency = 1;
		repeat
			so(1145251796, ShotPt, math.random(95, 105) / 100, 3)
			fq.CFrame = eP.Hit;
			MagnitudeDmg(fq, 2)
			Effects.Block(ShotPt.CFrame, Vector3.new(1, 1, 1), Vector3.new(), Vector3.new(.2, .2, .2), "Neon", "Pink", true, false, .1)
			Effects.Block(CFrame.new((ShotPt.Position + eP.Hit.p) / 2, eP.Hit.p), Vector3.new(1, 1, ShotPt.Position - eP.Hit.p.magnitude), Vector3.new(.2, .2, 1), Vector3.new(.1, .1, 0), "Neon", "Pink", false, false, .1)
			Effects.Block(eP.Hit, Vector3.new(1, 1, 1), Vector3.new(), Vector3.new(.2, .2, .2), "Neon", "Pink", true, false, .1)
			for b = 0, 1, .5 do
				swait()
				PlayAnimationFromTable({
					CFrame.new(2.25380063e-06, 0, 0.100001052, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
					CFrame.new(0.0823859125, 1.55974913, -0.0981838703, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
					CFrame.new(1.25785875, 0.5, -0.333723217, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
					CFrame.new(-1.05747044, 0.203263938, -0.563540041, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
					CFrame.new(0.423390329, -1.99999893, -0.0642812699, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
					CFrame.new(-0.57660532, -1.99999893, -0.0642794371, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782)
				}, .4, false)
			end;
			for b = 0, 1, .5 do
				swait()
				PlayAnimationFromTable({
					CFrame.new(0, 0, 0, 0.64278698, 0, -0.766044974, 0, 1, 0, 0.766044974, 0, 0.64278698),
					CFrame.new(0.0823832005, 1.55974865, -0.0981806219, 0.604022264, 0.219845936, 0.766044974, -0.342019916, 0.939692736, 0, -0.719846904, -0.262002617, 0.64278698),
					CFrame.new(1.02804303, 0.5, -0.52656126, 0.64278698, 0.766044974, 0, 0, 0, -1, -0.766044974, 0.64278698, 0),
					CFrame.new(-1.28728318, 0.203263342, -0.756378591, 0.875030518, -0.0895627737, 0.475710154, 0.480547935, 0.0424276218, -0.875941575, 0.0582684875, 0.995077074, 0.0801646709),
					CFrame.new(0.499997735, -1.99999893, -1.11758709e-06, 0.866025209, 0, -0.500000298, 0, 1, 0, 0.500000298, 0, 0.866025209),
					CFrame.new(-0.500001431, -1.99999893, -9.983778e-07, 0.766043782, 0, 0.64278847, 0, 1, 0, -0.64278847, 0, 0.766043782)
				}, .4, false)
			end
		until zhold == false;
		fq:Destroy()
		Humanoid.WalkSpeed = 16;
		attack = false
	end;
	function doge()
		attack = true;
		Humanoid.WalkSpeed = 0;
		so(536642316, Torso, 1, 1)
		local fm = Instance.new("BodyVelocity", RootPart)
		local fn = 10000000;
		fm.P = fn;
		fm.MaxForce = Vector3.new(fn, fn, fn)
		fm.Velocity = RootPart.CFrame.lookVector * 50;
		for b = 0, 1, .2 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -0.413182259, -0.492409885, 1, 0, 0, 0, 0.173647001, 0.984807968, 0, -0.984807968, 0.173647001),
				CFrame.new(0, 1.39017391, 0.409808099, 1, 0, 0, 0, 0.499998748, -0.866026163, 0, 0.866026163, 0.499998748),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1),
				CFrame.new(-0.5, -2, -2.86102295e-06, 1, 0, 0, 0, 1, 0, 0, 0, 1)
			}, .4, false)
			fm.Velocity = RootPart.CFrame.lookVector * 50
		end;
		for b = 0, 1, .2 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
				CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
				CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1)
			}, .4, false)
			fm.Velocity = RootPart.CFrame.lookVector * 50
		end;
		for b = 0, 1, .2 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
				CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
				CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388)
			}, .4, false)
			fm.Velocity = RootPart.CFrame.lookVector * 50
		end;
		fm:Destroy()
		Humanoid.WalkSpeed = 16;
		attack = false
	end;
	function bdoge()
		attack = true;
		Humanoid.WalkSpeed = 0;
		so(536642316, Torso, 1, 1)
		local fm = Instance.new("BodyVelocity", RootPart)
		local fn = 10000000;
		fm.P = fn;
		fm.MaxForce = Vector3.new(fn, fn, fn)
		fm.Velocity = RootPart.CFrame.lookVector * -50;
		for b = 0, 1, .2 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -2.22375727, 0.305265486, 1, 0, 0, 0, 0.500000238, -0.866025388, 0, 0.866025388, 0.500000238),
				CFrame.new(0, 1.35128808, -0.383415997, 1, 0, 0, 0, 0.766043901, 0.642788529, 0, -0.64278847, 0.766043901),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.19999337, -0.599998593, 1, 0, 0, 0, 1.00000024, 0, 0, 0, 1.00000024),
				CFrame.new(-0.500003815, -1.35979521, -0.923200667, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388)
			}, .4, false)
			fm.Velocity = RootPart.CFrame.lookVector * -50
		end;
		for b = 0, 1, .2 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -1.30470812, -0.622091293, 1, 0, 0, 0, -0.866025984, 0.499998987, 0, -0.499998987, -0.866025984),
				CFrame.new(0, 1.47984993, -0.230206192, 1, 0, 0, 0, 0.939693034, 0.34201926, 0, -0.34201926, 0.939693034),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1),
				CFrame.new(-0.5, -1.19999313, -0.600002289, 1, 0, 0, 0, 1, 0, 0, 0, 1)
			}, .4, false)
			fm.Velocity = RootPart.CFrame.lookVector * -50
		end;
		fm:Destroy()
		Humanoid.WalkSpeed = 16;
		attack = false
	end;
	function adoge()
		attack = true;
		Humanoid.WalkSpeed = 0;
		so(536642316, Torso, 1, 1)
		Effects.Wave(RootPart.CFrame * CFrame.Angles(math.rad(90), 0, 0), Vector3.new(), Vector3.new(1, .1, 1), "White", math.random(-10, 10), false, .1)
		BodyVel(RootPart, RootPart.CFrame.lookVector * 50)
		for b = 0, 1, .1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -0.095761165, -0.251516223, 1, 0, 0, 0, 0.939692736, 0.342019886, 0, -0.342019916, 0.939692736),
				CFrame.new(0, 1.43075883, 0.149916381, 1, 0, 0, 0, 0.939692736, -0.342019916, 0, 0.342019886, 0.939692736),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.96527231, 0.196966231, 1, 0, 0, 0, 0.984807789, 0.173648685, 0, -0.173648715, 0.984807789),
				CFrame.new(-0.5, -1.43618584, -0.205210268, 1, 0, 0, 0, 0.939692438, 0.342020929, 0, -0.342020959, 0.939692438)
			}, .4, false)
		end;
		Humanoid.WalkSpeed = 16;
		attack = false
	end;
	function badoge()
		attack = true;
		Humanoid.WalkSpeed = 0;
		so(536642316, Torso, 1, 1)
		Effects.Wave(RootPart.CFrame * CFrame.Angles(math.rad(-90), 0, 0), Vector3.new(), Vector3.new(1, .1, 1), "White", math.random(-10, 10), false, .1)
		BodyVel(RootPart, RootPart.CFrame.lookVector * -50)
		for b = 0, 1, .1 do
			swait()
			PlayAnimationFromTable({
				CFrame.new(0, -0.210508779, 0.312937856, 1, 0, 0, 0, 0.866025388, -0.500000238, 0, 0.500000238, 0.866025388),
				CFrame.new(0, 1.4075644, -0.288293391, 1, 0, 0, 0, 0.866025388, 0.500000238, 0, -0.500000238, 0.866025388),
				CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
				CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
				CFrame.new(0.5, -1.9652698, 0.196958005, 1, 0, 0, 0, 0.984807789, 0.173648715, 0, -0.173648685, 0.984807789),
				CFrame.new(-0.5, -1.43618536, -0.205215126, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676)
			}, .4, false)
		end;
		Humanoid.WalkSpeed = 16;
		attack = false
	end;
	eP.Button1Down:connect(function()
		if attack == false then
			zhold = true;
			shoot()
		end
	end)
	eP.Button1Up:connect(function()
		zhold = false
	end)
	local fr = 0;
	eP.KeyDown:connect(function(ap)
		ap = ap:lower()
		if ap == 'm' then
			if fp.IsPlaying == true then
				fp:Stop()
			elseif fp.IsPaused == true then
				fp:Play()
			end
		end;
		if attack == false then
			if ap == 'q' then
				if Anim == "Fall" or Anim == "Jump" then
					badoge()
				else
					bdoge()
				end
			elseif ap == 'e' then
				if Anim == "Fall" or Anim == "Jump" then
					adoge()
				else
					doge()
				end
			end
		end
	end)
	eP.KeyUp:connect(function(ap)
		ap = ap:lower()
		if ap == 'z' then
			zhold = false
		end
	end)
	for b, v in pairs(LuvGun:GetChildren()) do
		v.Transparency = 1
	end;
	coroutine.wrap(function()
		while 1 do
			swait()
			if eW <= 360 then
				eW = eW + 2
			else
				eW = 0
			end
		end
	end)()
	while true do
		swait()
		while true do
			swait()
			if Head:FindFirstChild("mus") == nil then
				fp = Instance.new("Sound", Head)
				fp.Name = "mus"
				fp.SoundId = "rbxassetid://1131624146"
				fp.Looped = true;
				fp.Volume = 1;
				fp:Play()
			end;
			if fr >= 1 then
				fr = fr - 1
			end;
			eU = RootPart.Velocity * Vector3.new(1, 0, 1).magnitude;
			eV = RootPart.Velocity.y;
			sine = sine + change;
			local eb, aj = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, eO)
			if RootPart.Velocity.y > 1 and eb == nil then
				Anim = "Jump"
				if attack == false then
					PlayAnimationFromTable({
						CFrame.new(0, 0.0382082276, -0.0403150208, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
						CFrame.new(0, 1.46579528, 0.0939689279, 1, 0, 0, 0, 0.939692855, -0.342019796, 0, 0.342019796, 0.939692855),
						CFrame.new(1.20945489, -0.213504896, 3.55388607e-07, 0.939692736, 0.342019916, 1.53461215e-07, -0.342019945, 0.939692736, 1.93715096e-07, -8.56816769e-08, -2.23517418e-07, 1.00000012),
						CFrame.new(-1.20945573, -0.213503733, 5.0439985e-07, 0.939692736, -0.342019916, -1.53461215e-07, 0.342019945, 0.939692736, 1.93715096e-07, 8.56816769e-08, -2.23517418e-07, 1.00000012),
						CFrame.new(0.5, -1.99739456, -0.0180913229, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
						CFrame.new(-0.5, -1.30000103, -0.39999947, 1, 0, 0, 0, 0.939692676, 0.342020601, 0, -0.342020601, 0.939692676)
					}, .3, false)
				end
			elseif RootPart.Velocity.y < -1 and eb == nil then
				Anim = "Fall"
				if attack == false then
					PlayAnimationFromTable({
						CFrame.new(0, -0.0646628663, 0.0399149321, 1, 0, 0, 0, 0.984807849, -0.173647985, 0, 0.173647985, 0.984807849),
						CFrame.new(0, 1.4913609, -0.128171027, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855),
						CFrame.new(1.55285025, 0.466259956, -9.26282269e-08, 0.766043842, -0.642788351, -6.46188241e-08, 0.642788291, 0.766043961, -7.4505806e-08, 1.04308128e-07, 1.49011612e-08, 1.00000012),
						CFrame.new(-1.5605253, 0.475036323, -2.10609159e-07, 0.766043842, 0.642788351, 6.46188241e-08, -0.642788291, 0.766043961, -7.4505806e-08, -1.04308128e-07, 1.49011612e-08, 1.00000012),
						CFrame.new(0.500000954, -1.9973948, -0.0180922765, 1, 0, 0, 0, 1.00000012, 0, 0, 0, 1.00000012),
						CFrame.new(-0.499999046, -1.30000043, -0.400000483, 1, 0, 0, 0, 0.939692855, 0.342019796, 0, -0.342019796, 0.939692855)
					}, .3, false)
				end
			elseif eU < 1 and eb ~= nil then
				Anim = "Idle"
				if attack == false then
					change = 1;
					PlayAnimationFromTable({
						CFrame.new(-0.0769465268, -7.7815578e-08, -0.031559173, 0.939695537, 1.01607293e-06, 0.342021346, 7.9855522e-07, 1.00000191, 5.12654879e-07, -0.342019558, 2.16066837e-07, 0.939692855) * CFrame.new(0, .05 * math.cos(sine / 10), 0),
						CFrame.new(0.0615186803, 1.4999913, 0.0559706129, 0.939695537, 7.9855522e-07, -0.342019558, 1.01607293e-06, 1.00000191, 2.16066837e-07, 0.342021346, 5.12654879e-07, 0.939692855),
						CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
						CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
						CFrame.new(0.500003159, -2.00000715, -1.98185444e-06, 0.939692736, 0, -0.342019916, 0, 1, 0, 0.342019886, 0, 0.939692736) * CFrame.new(0, -.05 * math.cos(sine / 10), 0),
						CFrame.new(-0.500018835, -2.0000062, 2.08616257e-07, 0.939692438, 0, 0.342020929, 0, 1, 0, -0.342020959, 0, 0.939692438) * CFrame.new(0, -.05 * math.cos(sine / 10), 0)
					}, .3, false)
				end
			elseif eU > 2 and eb ~= nil then
				Anim = "Walk"
				if attack == false then
					Humanoid.WalkSpeed = 16;
					PlayAnimationFromTable({
						CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1) * CFrame.new(0, 0 - .08 * math.cos(sine / 2.5), 0) * CFrame.Angles(0, 0, 0),
						CFrame.new(0, 1.48263013, -0.0984808952, 1, 0, 0, 0, 0.984807849, 0.173647985, 0, -0.173647985, 0.984807849),
						CFrame.new(0.858022809, 0.339910388, -0.78796947, 0.296197057, 0.813798428, 0.499999553, 0.171009049, 0.469846249, -0.866025627, -0.939693213, 0.342018723, 1.7801861e-07),
						CFrame.new(-1.12680423, -0.351213962, -0.287614167, 0.0669000372, 0.109107949, 0.991776109, 0.843825459, 0.52423954, -0.114593051, -0.532431304, 0.844552159, -0.05699642),
						CFrame.new(0.540300786, -1.99793816, -9.82598067e-07, 0.998698533, -0.0510031395, 6.36324955e-07, 0.0510031395, 0.998698533, -1.00461093e-05, -8.35937328e-08, 1.08393433e-05, 1.00000024) * CFrame.new(0, 0, 0 + .5 * math.cos(sine / 5)) * CFrame.Angles(math.rad(0 - 30 * math.cos(sine / 5)), 0, 0),
						CFrame.new(-0.539563596, -1.99794078, 1.12228372e-06, 0.998635888, 0.0523072146, -1.77852357e-07, -0.0523072146, 0.998635888, -1.00715051e-05, -3.89727461e-07, 1.08406466e-05, 1.00000024) * CFrame.new(0, 0, 0 - .5 * math.cos(sine / 5)) * CFrame.Angles(math.rad(0 + 30 * math.cos(sine / 5)), 0, 0)
					}, .3, false)
				end
			end
		end
	end
end)
c:CreateButton("Banzai Bazooka", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	local script = game:GetObjects("rbxassetid://6730580482")[1]
	local fs = script;
	local ft = game.Players.LocalPlayer.Character.Shiba;
	local fu = game.Players.LocalPlayer;
	local fv = ft.Humanoid;
	local fw = fs.Event;
	local fx = fv.Torso;
	local fy = ft.Head;
	local TORSO = ft.Torso;
	local fz = ft["Right Arm"]
	local fA = ft["Left Arm"]
	local fB = ft["Right Leg"]
	local fC = ft["Left Leg"]
	local fD = fx["RootJoint"]
	local fE = TORSO["Neck"]
	local fF = TORSO["Right Shoulder"]
	local fG = TORSO["Left Shoulder"]
	local fH = TORSO["Right Hip"]
	local fI = TORSO["Left Hip"]
	local fJ = fx.Position;
	IT = Instance.new;
	CF = CFrame.new;
	VT = Vector3.new;
	RAD = math.rad;
	C3 = Color3.new;
	UD2 = UDim2.new;
	BRICKC = BrickColor.new;
	ANGLES = CFrame.Angles;
	EULER = CFrame.fromEulerAnglesXYZ;
	COS = math.cos;
	ACOS = math.acos;
	SIN = math.sin;
	ASIN = math.asin;
	ABS = math.abs;
	MRANDOM = math.random;
	FLOOR = math.floor;
	local fK = game.Players.LocalPlayer;
	local Player = fK;
	local eP, mouse, fL, fM = game.Players.LocalPlayer:GetMouse(), game.Players.LocalPlayer:GetMouse(), game:GetService("UserInputService"), game:GetService("ContextActionService")
	local function af(ag, ah)
		attachment = Instance.new("Attachment", ag)
		attachment.Position = Vector3.new(0.3, 0, 0)
		attachment.Orientation = Vector3.new(-45, 90, 0)
		attachment02 = Instance.new("Attachment", ah)
		lol = Instance.new("AlignPosition", ag)
		lol.Attachment0 = attachment;
		lol.Attachment1 = attachment02;
		lol.MaxForce = 67734;
		lol.RigidityEnabled = true;
		pog = Instance.new("AlignOrientation", ag)
		pog.Attachment0 = attachment;
		pog.Attachment1 = attachment02;
		pog.Responsiveness = 200;
		pog.RigidityEnabled = true
	end;
	game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle:BreakJoints()
	af(game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle, script.Bazooka)
	script.Bazooka.Transparency = 1;
	local fN = 3;
	local fO = fu:GetMouse()
	local fJ = eP.Hit.p;
	local fP = 1 / 60;
	local fQ = 2 / fN;
	local fR = 1;
	local fS = "Idle"
	local fT = false;
	local fU = false;
	local fV = 0;
	local fW = false;
	local Debris = game:GetService("Debris")
	local Effects = IT("Folder", ft)
	Effects.Name = "FXFolder"
	local fX = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local fY = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local fZ = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local f_ = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local g0 = 213546066;
	local g2 = 2671146857;
	local g3 = 9999999999999;
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"
	script:WaitForChild("ArtificialHB")
	frame = fP;
	tf = 0;
	allowframeloss = false;
	tossremainder = false;
	lastframe = tick()
	script.ArtificialHB:Fire()
	game:GetService("RunService").Heartbeat:connect(function(am, aG)
		tf = tf + am;
		if tf >= frame then
			if allowframeloss then
				ArtificialHB:Fire()
				lastframe = tick()
			else
				for b = 1, math.floor(tf / frame) do
					ArtificialHB:Fire()
				end;
				lastframe = tick()
			end;
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	function PositiveAngle(g4)
		if g4 >= 0 then
			g4 = 0
		end;
		return g4
	end;
	function NegativeAngle(g4)
		if g4 <= 0 then
			g4 = 0
		end;
		return g4
	end;
	function Swait(g4)
		if g4 == 0 or g4 == nil then
			ArtificialHB.Event:wait()
		else
			for b = 1, g4 do
				ArtificialHB.Event:wait()
			end
		end
	end;
	function QuaternionFromCFrame(cf)
		local ca, cb, cc, cd, ce, cg, ch, ci, cj, ck, cl, cm = cf:components()
		local cn = cd + ci + cm;
		if cn > 0 then
			local am = math.sqrt(1 + cn)
			local co = 0.5 / am;
			return (cl - cj) * co, (cg - ck) * co, (ch - ce) * co, am * 0.5
		else
			local b = 0;
			if ci > cd then
				b = 1
			end;
			if cm > (b == 0 and cd or ci) then
				b = 2
			end;
			if b == 0 then
				local am = math.sqrt(cd - ci - cm + 1)
				local co = 0.5 / am;
				return 0.5 * am, (ch + ce) * co, (ck + cg) * co, (cl - cj) * co
			elseif b == 1 then
				local am = math.sqrt(ci - cm - cd + 1)
				local co = 0.5 / am;
				return (ce + ch) * co, 0.5 * am, (cl + cj) * co, (cg - ck) * co
			elseif b == 2 then
				local am = math.sqrt(cm - cd - ci + 1)
				local co = 0.5 / am;
				return (cg + ck) * co, (cj + cl) * co, 0.5 * am, (ch - ce) * co
			end
		end
	end;
	function QuaternionToCFrame(cp, cq, cr, U, V, aL, cs)
		local ct, cu, cv = U + U, V + V, aL + aL;
		local cw, cx, cy = cs * ct, cs * cu, cs * cv;
		local cz = U * ct;
		local cA = U * cu;
		local cB = U * cv;
		local cC = V * cu;
		local cD = V * cv;
		local cE = aL * cv;
		return CFrame.new(cp, cq, cr, 1 - (cC + cE), cA - cy, cB + cx, cA + cy, 1 - (cz + cE), cD - cw, cB - cx, cD + cw, 1 - (cz + cC))
	end;
	function QuaternionSlerp(a, j, t)
		local cF = a[1] * j[1] + a[2] * j[2] + a[3] * j[3] + a[4] * j[4]
		local cG, cH;
		if cF >= 0.0001 then
			if 1 - cF > 0.0001 then
				local cI = ACOS(cF)
				local cJ = 1 / SIN(cI)
				cG = SIN((1 - t) * cI) * cJ;
				cH = SIN(t * cI) * cJ
			else
				cG = 1 - t;
				cH = t
			end
		else
			if 1 + cF > 0.0001 then
				local cI = ACOS(-cF)
				local cJ = 1 / SIN(cI)
				cG = SIN((t - 1) * cI) * cJ;
				cH = SIN(t * cI) * cJ
			else
				cG = t - 1;
				cH = t
			end
		end;
		return a[1] * cG + j[1] * cH, a[2] * cG + j[2] * cH, a[3] * cG + j[3] * cH, a[4] * cG + j[4] * cH
	end;
	function Clerp(a, j, t)
		local c1 = {
			QuaternionFromCFrame(a)
		}
		local c2 = {
			QuaternionFromCFrame(j)
		}
		local c3, c4, c5 = a.x, a.y, a.z;
		local c6, c7, c8 = j.x, j.y, j.z;
		local c9 = 1 - t;
		return QuaternionToCFrame(c9 * c3 + t * c6, c9 * c4 + t * c7, c9 * c5 + t * c8, QuaternionSlerp(c1, c2, t))
	end;
	function WeldParts(A, B)
		local g5 = IT("ManualWeld")
		g5.Part0 = A;
		g5.Part1 = B;
		g5.C1 = B.CFrame:inverse() * A.CFrame;
		g5.Parent = A;
		return g5
	end;
	function NewSound(g6)
		local ed = "rbxassetid://" .. (g6.ID or 0)
		local ee = g6.PARENT or fx;
		local ef = g6.VOLUME or 0.5;
		local eg = g6.PITCH or 1;
		local g7 = g6.LOOP or false;
		local g8 = g6.MAXDISTANCE or 100;
		local g9 = g6.EMITTERSIZE or 10;
		local ga = g6.PLAYING or true;
		local gb = g6.PLAYONREMOVE or false;
		local gc = g6.DOESDEBRIS or true;
		if ed ~= "rbxassetid://0" then
			local SOUND = IT("Sound", ee)
			SOUND.SoundId = ed;
			SOUND.Volume = ef;
			SOUND.Pitch = eg;
			SOUND.Looped = g7;
			SOUND.MaxDistance = g8;
			SOUND.EmitterSize = g9;
			SOUND.PlayOnRemove = gb;
			if gc == true and ga == true and g7 == false then
				Debris:AddItem(SOUND, SOUND.TimeLength + 5)
			end;
			if ga == true then
				SOUND:Play()
			end;
			return SOUND
		end
	end;
	function ManSlaughter(gd)
		return
	end;
	function AreaOfEffect(ge, gf, gg, gh)
		local gi = {}
		for gj, gk in pairs(workspace:GetChildren()) do
			if gk:FindFirstChildOfClass("Humanoid") then
				local gl = gk:FindFirstChildOfClass("Humanoid")
				local fx = gl.Torso;
				if fx then
					if fx.Position - ge.Magnitude <= gf then
						if gh == true then
							if gk ~= ft then
								table.insert(gi, {
									gk,
									gl,
									fx
								})
							end
						else
							if gk ~= ft then
								ManSlaughter(gk)
							end
						end
					end
				end
			end
		end;
		if gh == true then
			return gi
		end
	end;
	function CreatePart(gm, ee, gn, go, gp, gq, gr, gs, gt)
		local gu = IT("Part")
		gu.formFactor = gm;
		gu.Reflectance = go;
		gu.Transparency = gp;
		gu.CanCollide = false;
		gu.Locked = true;
		gu.Anchored = true;
		if gt == false then
			gu.Anchored = false
		end;
		gu.BrickColor = BRICKC(tostring(gq))
		gu.Name = gr;
		gu.Size = gs;
		gu.Position = fx.Position;
		gu.Material = gn;
		gu:BreakJoints()
		gu.Parent = ee;
		return gu
	end;
	function Raycast(gv, gw, gf, gx)
		return workspace:FindPartOnRay(Ray.new(gv, gw.unit * gf), gx)
	end;
	function CameraShake(ge, gf, gy, gz)
		for gj, gk in pairs(workspace:GetChildren()) do
			if gk:FindFirstChildOfClass("Humanoid") then
				local gl = gk:FindFirstChildOfClass("Humanoid")
				local fx = gl.Torso;
				if fx and game.Players:GetPlayerFromCharacter(gk) then
					if fx.Position - ge.Magnitude <= gf then
						if gk:FindFirstChild("CamShake") then
							Debris:AddItem(gk:FindFirstChild("CamShake"), 0.05)
						end;
						local gA = script.CamShake:Clone()
						gA.Parent = gk;
						local gB = IT("NumberValue", gA)
						gB.Name = "Timer"
						gB.Value = gz;
						local gC = IT("NumberValue", gA)
						gC.Name = "Shake"
						gC.Value = gy;
						gA.Disabled = false;
						Debris:AddItem(gA, 15)
					end
				end
			end
		end
	end;
	local gD = fs.Helmet;
	gD.Parent = ft;
	for gj, gk in pairs(ft:GetChildren()) do
		if gk ~= fx then
			if gk:IsA("Accessory") then
			end
		end
	end;
	gD.CFrame = fy.CFrame * CF(0, 0.5, 0)
	gD.Anchored = false;
	WeldParts(fy, gD)
	local gE = fs.Bazooka;
	gE.Parent = ft;
	gE.Anchored = false;
	local gF = IT("Motor6D")
	gF.Part0 = fz;
	gF.Part1 = gE;
	gF.C0 = CF(0, -1, -0.5) * ANGLES(RAD(-90), 0, 0) * CF(0, 0, 1.85)
	local gG = gF.C0;
	gF.Parent = fz;
	for b = 1, 15 do
		local gH = CreatePart(3, ft, "Fabric", 0, 0 + (b - 1) / 15.2, "Dark stone grey", "FaceGradient", VT(1.01, 0.58, 1.01), false)
		gH.Color = C3(0, 0, 0)
		fy:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = gH;
		gH.CFrame = fy.CFrame * CF(0, 0.3 - (b - 1) / 35, 0)
		WeldParts(fy, gH)
	end;
	local gI = fs.Missile;
	gI.Parent = nil;
	local gJ = fs.ControlsGUI;
	gJ.Parent = fu.PlayerGui;
	gJ.ToggleButton.MouseButton1Click:Connect(function()
		if gJ.ToggleButton.Controls.Visible == false then
			gJ.ToggleButton.Controls.Visible = true
		elseif gJ.ToggleButton.Controls.Visible == true then
			gJ.ToggleButton.Controls.Visible = false
		end
	end)
	local gK = gJ.ToggleButton.Stored;
	gK.Text = "STORED: " .. g3;
	function AddTo(gL)
		g3 = g3 + gL;
		gK.Text = "STORED: " .. g3
	end;
	function Fire_in_the_hole()
		if g3 > 0 then
			fW = true;
			local gM = IT("BodyGyro")
			gM.D = 50;
			gM.P = 5000;
			gM.MaxTorque = VT(0, 4000000, 0)
			gM.CFrame = CF(fx.Position, eP.Hit.p)
			gM.Parent = fx;
			fW = true;
			coroutine.resume(coroutine.create(function()
				repeat
					Swait()
					gM.CFrame = CF(fx.Position, eP.Hit.p)
				until fW == false;
				gM:Remove()
			end))
			repeat
				for b = 0, 0.06, 0.1 / fN do
					Swait()
					fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / fN)
					fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / fN)
					fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * fZ, 2.5 / fN)
					fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * f_, 1.5 / fN)
					fH.C0 = Clerp(fH.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / fN)
					fI.C0 = Clerp(fI.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / fN)
				end;
				AddTo(-1)
				coroutine.resume(coroutine.create(function()
					local gN = eP.Hit.p;
					local gO = gI:Clone()
					gO.Parent = Effects;
					gO.CFrame = CF(gE.CFrame * CF(0, 0, -2).p, gN)
					NewSound({
						ID = 440145223,
						PARENT = gE,
						VOLUME = 2,
						PITCH = MRANDOM(9, 11) / 10,
						LOOP = false,
						MAXDISTANCE = 80,
						EMITTERSIZE = 15,
						PLAYING = true,
						PLAYONREMOVE = false,
						DOESDEBRIS = true
					})
					NewSound({
						ID = 440145223,
						PARENT = gO,
						VOLUME = 2,
						PITCH = MRANDOM(9, 11) / 10,
						LOOP = false,
						MAXDISTANCE = 80,
						EMITTERSIZE = 15,
						PLAYING = true,
						PLAYONREMOVE = false,
						DOESDEBRIS = true
					})
					for b = 1, 200 do
						Swait()
						local gi, gP = Raycast(gO.Position, gO.CFrame.lookVector, 5, ft)
						if gi then
							gO.CFrame = CF(gP)
							break
						end;
						gO.CFrame = gO.CFrame * CF(0, 0, -4)
					end;
					gO.Transparency = 1;
					gO.Hind:Remove()
					gO.CFrame = CF(gO.Position)
					gO.Size = VT(0, 0, 0)
					NewSound({
						ID = 142070127,
						PARENT = gO,
						VOLUME = 7,
						PITCH = MRANDOM(8, 12) / 10,
						LOOP = false,
						MAXDISTANCE = 300,
						EMITTERSIZE = 15,
						PLAYING = true,
						PLAYONREMOVE = false,
						DOESDEBRIS = true
					})
					for gj, gk in pairs(script.Grenade:GetChildren()) do
						local gQ = gk:Clone()
						gQ.Parent = gO;
						gQ:Emit(125)
					end;
					CameraShake(gO.Position, 50, 125, 70)
					AreaOfEffect(gO.Position, 35, 200, false)
					Debris:AddItem(gO, 2)
				end))
				for b = 0, 0.025, 0.1 / fN do
					Swait()
					fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / fN)
					fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / fN)
					fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * fZ, 2.5 / fN)
					fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * f_, 1.5 / fN)
					fH.C0 = Clerp(fH.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / fN)
					fI.C0 = Clerp(fI.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4, 0, 0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / fN)
				end
			until fU == false or g3 <= 0;
			if g3 <= 0 then
				g3 = 0;
				gK.Text = "STORED: 0"
			end;
			fW = false
		end
	end;
	function Store()
		fv.WalkSpeed = 0;
		fv.JumpPower = 0;
		fW = true;
		repeat
			for b = 0, 0.01, 0.1 / fN do
				Swait()
				gF.C0 = Clerp(gF.C0, CF(0, -1, -0.5) * ANGLES(RAD(-80), RAD(15), 0) * CF(0, 0, 1.85), 2.5 / fN)
				fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02 + 0.05 * COS(fV / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / fN)
				fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / fN)
				fF.C0 = Clerp(fF.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * fZ, 2.5 / fN)
				fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * f_, 2.5 / fN)
				fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
				fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
			end;
			local gO = gI:Clone()
			gO.Anchored = false;
			gO:ClearAllChildren()
			gO.CFrame = fA.CFrame * CF(0, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
			gO.Parent = ft;
			WeldParts(gO, fA)
			for b = 0, 0.02, 0.1 / fN do
				Swait()
				gF.C0 = Clerp(gF.C0, CF(0, -1, -0.5) * ANGLES(RAD(-80), RAD(15), 0) * CF(0, 0, 1.85), 2.5 / fN)
				fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02 + 0.05 * COS(fV / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / fN)
				fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / fN)
				fF.C0 = Clerp(fF.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * fZ, 2.5 / fN)
				fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * f_, 2.5 / fN)
				fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
				fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
			end;
			for b = 0, 0.02, 0.1 / fN do
				Swait()
				gF.C0 = Clerp(gF.C0, CF(0, -1, -0.5) * ANGLES(RAD(-80), RAD(15), 0) * CF(0, 0, 1.85), 2.5 / fN)
				fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02 + 0.05 * COS(fV / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / fN)
				fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / fN)
				fF.C0 = Clerp(fF.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * fZ, 2.5 / fN)
				fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * f_, 2.5 / fN)
				fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
				fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / fN)
			end;
			NewSound({
				ID = 440145223,
				PARENT = gE,
				VOLUME = 1,
				PITCH = MRANDOM(9, 11) / 6,
				LOOP = false,
				MAXDISTANCE = 80,
				EMITTERSIZE = 15,
				PLAYING = true,
				PLAYONREMOVE = false,
				DOESDEBRIS = true
			})
			for b = 0, 0.05, 0.1 / fN do
				Swait()
				gF.C0 = Clerp(gF.C0, CF(0, -1, -0.5) * ANGLES(RAD(-80), RAD(15), 0) * CF(0, 0, 1.85), 2.5 / fN)
				fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02 + 0.05 * COS(fV / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / fN)
				fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / fN)
				fF.C0 = Clerp(fF.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * fZ, 2.5 / fN)
				fG.C0 = Clerp(fG.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * f_, 2.5 / fN)
				fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / fN)
				fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / fN)
			end;
			gO:Remove()
			gE.Face.Pop:Emit(5)
			AddTo(1)
		until fT == false;
		fW = false;
		fv.WalkSpeed = 100;
		fv.JumpPower = 50
	end;
	function Dance()
		fv.WalkSpeed = 0;
		fv.JumpPower = 0;
		fW = true;
		local gR = false;
		local gS = nil;
		if fx:FindFirstChild("BGM_MUSIC") then
			gS = fx:FindFirstChild("BGM_MUSIC")
			gS.Volume = 5
		else
			gS = NewSound({
				ID = g2,
				PARENT = fx,
				VOLUME = 5,
				PITCH = 1,
				LOOP = true,
				MAXDISTANCE = 300,
				EMITTERSIZE = 300,
				PLAYING = true,
				PLAYONREMOVE = false,
				DOESDEBRIS = true
			})
			gR = true
		end;
		gS.SoundId = "rbxassetid://" .. g2;
		gS:Play()
		local gT = false;
		local gU = mouse.KeyDown:connect(function(aE)
			aE = aE:lower()
			local gV = aE;
			if gV == "m" then
				gT = true;
				fW = false;
				if gR == true then
					gS:Remove()
				else
					gS:Play()
					gS.Volume = 1.25;
					gS.SoundId = "rbxassetid://" .. g0
				end
			end
		end)
		local gW = 0;
		local gX = IT("PointLight", fx)
		gX.Brightness = 25;
		gX.Color = BrickColor.random().Color;
		repeat
			gW = gW + 2;
			Swait()
			gX.Color = BrickColor.random().Color;
			fD.C0 = Clerp(fD.C0, fX * CF(0 - 0.32 * SIN(gW / 10), 0, -0.55 - 0.05 * COS(gW / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(gW / 10)), RAD(0)), 1.5 / fN)
			fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0 - 20 * SIN(gW / 10)), RAD(0)), 1.5 / fN)
			fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(gW / 10))) * CF(0, -1, 0) * fZ, 1.5 / fN)
			fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(gW / 10))) * CF(0, -1, 0) * f_, 1.5 / fN)
			fH.C0 = Clerp(fH.C0, CF(1.35, -0.475 + 0.36 * SIN(gW / 10) + 0.05 * COS(gW / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(gW / 10)), RAD(0), RAD(0)), 1.5 / fN)
			fI.C0 = Clerp(fI.C0, CF(-1.35, -0.475 - 0.36 * SIN(gW / 10) + 0.05 * COS(gW / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(gW / 10)), RAD(0), RAD(0)), 1.5 / fN)
		until gT == true;
		gX:Remove()
		gU:Disconnect()
		if gR == true then
			gS:Remove()
		else
			gS:Play()
			gS.Volume = 1.25;
			gS.SoundId = "rbxassetid://" .. g0
		end;
		fW = false;
		fv.WalkSpeed = 100;
		fv.JumpPower = 50
	end;
	mouse.Button1Down:connect(function()
		fU = true;
		if fW == false then
			Fire_in_the_hole()
		end
	end)
	mouse.Button1Up:connect(function()
		fU = false
	end)
	mouse.KeyDown:connect(function(aE)
		aE = aE:lower()
		local gV = aE;
		fT = true;
		if gV == "z" then
			Store()
		elseif gV == "m" then
			Dance()
		elseif gV == "t" then
			NewSound({
				ID = 145757437,
				PARENT = fx,
				VOLUME = 10,
				PITCH = 1,
				LOOP = false,
				MAXDISTANCE = 100,
				EMITTERSIZE = 25,
				PLAYING = true,
				PLAYONREMOVE = false,
				DOESDEBRIS = true
			})
		elseif gV == "e" then
			if fx:FindFirstChild("BGM_MUSIC") then
				fx:FindFirstChild("BGM_MUSIC"):Remove()
			else
				local gY = NewSound({
					ID = g0,
					PARENT = fx,
					VOLUME = 1.25,
					PITCH = 1,
					LOOP = true,
					MAXDISTANCE = 300,
					EMITTERSIZE = 300,
					PLAYING = true,
					PLAYONREMOVE = false,
					DOESDEBRIS = true
				})
				gY.Name = "BGM_MUSIC"
			end
		end
	end)
	mouse.KeyUp:connect(function()
		fT = false
	end)
	local gY = NewSound({
		ID = g0,
		PARENT = fx,
		VOLUME = 1.25,
		PITCH = 1,
		LOOP = true,
		MAXDISTANCE = 300,
		EMITTERSIZE = 300,
		PLAYING = true,
		PLAYONREMOVE = false,
		DOESDEBRIS = true
	})
	gY.Name = "BGM_MUSIC"
	fv.WalkSpeed = 100;
	while true do
		Swait()
		local fJ = eP.Hit.p;
		fV = fV + fQ;
		if ft:FindFirstChild("Animate") then
			ft:FindFirstChild("Animate"):Destroy()
		end;
		if ft:FindFirstChild("Sound") then
			ft:FindFirstChild("Sound"):Destroy()
		end;
		for a3, v in next, fv:GetPlayingAnimationTracks() do
			v:Stop()
		end;
		local gZ = fx.Velocity * VT(1, 0, 1).magnitude;
		local g_ = fx.Velocity.y;
		local h0 = Raycast(fx.Position, CF(fx.Position, fx.Position + VT(0, -1, 0)).lookVector, 4 + fv.HipHeight, ft)
		local h1 = 0.5;
		local h2 = fv.Sit;
		if fS == "Walk" and gZ > 1 and h2 == false then
			fH.C1 = Clerp(fH.C1, CF(0.5, 0.875 - 0.3 * SIN(fV / h1), -0.5 * COS(fV / h1) + 0.2 + 0.2 * COS(fV / h1)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - fB.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(fV / h1))), 2 / fN)
			fI.C1 = Clerp(fI.C1, CF(-0.5, 0.875 + 0.3 * SIN(fV / h1), 0.5 * COS(fV / h1) + 0.2 + -0.2 * COS(fV / h1)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + fC.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(fV / h1))), 2 / fN)
		elseif fS ~= "Walk" or gZ < 1 or h2 == true then
			fH.C1 = Clerp(fH.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / fN)
			fI.C1 = Clerp(fI.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / fN)
		end;
		if fW == false then
			gF.C0 = Clerp(gF.C0, gG, 1.5 / fN)
		end;
		if h2 == false then
			if h0 then
				if gZ < 1 and h0 ~= nil then
					fS = "Idle"
					if fW == false then
						fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.02 + 0.05 * COS(fV / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / fN)
						fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0 - 2.5 * COS(fV / 6)), RAD(0), RAD(0)), 1.5 / fN)
						fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(fV / 6))) * fZ, 1.5 / fN)
						fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(fV / 6))) * f_, 1.5 / fN)
						fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / fN)
						fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / fN)
					end
				elseif gZ > 1 and h0 ~= nil then
					fS = "Walk"
					if fW == false then
						fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.05 + 0.05 * COS(fV / h1)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / fN)
						fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / fN)
						fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(fV / h1))) * fZ, 2 / fN)
						fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(fV / h1))) * f_, 2 / fN)
						fH.C0 = Clerp(fH.C0, CF(1, -1 - 0.05 * COS(fV / h1), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / fN)
						fI.C0 = Clerp(fI.C0, CF(-1, -1 - 0.05 * COS(fV / h1), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / fN)
					end
				end
			else
				if g_ > 0 then
					fS = "Jump"
					if fW == false then
						fD.C0 = Clerp(fD.C0, fX * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / fN)
						fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / fN)
						fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(fV / 6))) * fZ, 1.5 / fN)
						fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * f_, 1 / fN)
						fH.C0 = Clerp(fH.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / fN)
						fI.C0 = Clerp(fI.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / fN)
					end
				else
					fS = "Fall"
					if fW == false then
						fD.C0 = Clerp(fD.C0, fX * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / fN)
						fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / fN)
						fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(fV / 6))) * fZ, 1.5 / fN)
						fG.C0 = Clerp(fG.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * f_, 1 / fN)
						fH.C0 = Clerp(fH.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / fN)
						fI.C0 = Clerp(fI.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / fN)
					end
				end
			end
		else
			fS = "Sit"
			if fW == false then
				fD.C0 = Clerp(fD.C0, fX * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / fN)
				fE.C0 = Clerp(fE.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / fN)
				fF.C0 = Clerp(fF.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * fZ, 1.5 / fN)
				fG.C0 = Clerp(fG.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45)) * CF(0, -0.25, 0) * f_, 1.25 / fN)
				fH.C0 = Clerp(fH.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / fN)
				fI.C0 = Clerp(fI.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / fN)
			end
		end
	end
end)
c:CreateButton("Arsenal Delinquent", function()
	if not game.Players.LocalPlayer.Character:FindFirstChild("Shiba") then
		return
	end;
	local script = game:GetObjects("rbxassetid://6726523130")[1]
	local Player = game.Players.LocalPlayer;
	local eP, mouse, fL, fM = game.Players.LocalPlayer:GetMouse(), game.Players.LocalPlayer:GetMouse(), game:GetService("UserInputService"), game:GetService("ContextActionService")
	wait(0.2)
	PlayerGui = Player.PlayerGui;
	Cam = workspace.CurrentCamera;
	Backpack = Player.Backpack;
	Character = Player.Character.Shiba;
	Humanoid = Character.Humanoid;
	RootPart = Character.HumanoidRootPart;
	Torso = Character.Torso;
	Head = Character.Head;
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart.RootJoint;
	Neck = Torso.Neck;
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local fJ = RootPart.Position;
	local h3 = 0;
	local h4 = Instance.new("Sound", Torso)
	IT = Instance.new;
	CF = CFrame.new;
	VT = Vector3.new;
	RAD = math.rad;
	C3 = Color3.new;
	UD2 = UDim2.new;
	BRICKC = BrickColor.new;
	ANGLES = CFrame.Angles;
	EULER = CFrame.fromEulerAnglesXYZ;
	COS = math.cos;
	ACOS = math.acos;
	SIN = math.sin;
	ASIN = math.asin;
	ABS = math.abs;
	MRANDOM = math.random;
	FLOOR = math.floor;
	Animation_Speed = 3;
	Frame_Speed = 0.016666666666666666;
	local h5 = false;
	Frame_Speed = 1 / 80;
	local dx = 25;
	local fX = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local fY = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local fZ = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local f_ = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local fR = 1;
	local fS = "Idle"
	local h6 = false;
	local h7 = IT("Sound", RootPart)
	local ef = 2;
	local eg = 1;
	local h8 = 1305709235;
	local h9 = false;
	local ha = false;
	local hb = 1;
	local dJ = "Ban"
	local hc = "Ur damn skids nigga"
	local hd = false;
	local fV = 0;
	local gs = 1;
	local fT = false;
	local fQ = 2 / Animation_Speed;
	local he = false;
	local hg = false;
	local hh = false;
	local hi = IT("Animation")
	hi.Name = "Roblox Idle Animation"
	hi.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	local hj = IT("ScreenGui", PlayerGui)
	hj.Name = "BanishV3Gui"
	local hk = IT("Model")
	hk.Name = "shackisgaylol"
	local hl = IT("Model")
	hl.Name = "shackismegagaylol"
	local Effects = IT("Folder", hl)
	Effects.Name = "Effects"
	local hm = IT("Folder", hk)
	Effects.Name = "Effects"
	local ez = Humanoid.Animator;
	local eA = Character:FindFirstChild("Animate")
	local hn = true;
	local ho = {}
	script.Parent = PlayerGui;
	frame = Frame_Speed;
	tf = 0;
	allowframeloss = false;
	tossremainder = false;
	lastframe = tick()
	game:GetService("RunService").Heartbeat:connect(function(am, aG)
		tf = tf + am;
		if tf >= frame then
			if allowframeloss then
				lastframe = tick()
			else
				for b = 1, math.floor(tf / frame) do
				end;
				lastframe = tick()
			end;
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	local hp = {}
	for a3, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") and c.Name ~= "Handle" then
			if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
				c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end;
			table.insert(hp, {
				c,
				c.Parent,
				c.Material,
				c.Color,
				c.Transparency
			})
		elseif c:IsA("JointInstance") then
			table.insert(hp, {
				c,
				c.Parent,
				nil,
				nil,
				nil
			})
		end
	end;
	for eH = 1, #hp do
		if hp[eH] ~= nil then
			local hq = hp[eH]
			local hr = hq[1]
			local ee = hq[2]
			local gn = hq[3]
			local hs = hq[4]
			local gp = hq[5]
			if hr.ClassName == "Part" and hr ~= RootPart then
				hr.Material = gn;
				hr.Color = hs;
				hr.Transparency = gp
			end;
			hr.AncestryChanged:Connect(function()
				hr.Parent = ee
			end)
		end
	end;
	function refit()
		Character.Parent = workspace;
		for eH = 1, #hp do
			if hp[eH] ~= nil then
				local hq = hp[eH]
				local hr = hq[1]
				local ee = hq[2]
				local gn = hq[3]
				local hs = hq[4]
				local gp = hq[5]
				if hr:IsA("BasePart") and hr ~= RootPart then
					hr.Material = gn;
					hr.Color = hs;
					hr.Transparency = gp + EXTRATRANS
				end;
				if hr.Parent ~= ee then
					Humanoid:remove()
					hr.Parent = ee;
					Humanoid = IT("Humanoid", Character)
				end
			end
		end
	end;
	function Raycast(gv, gw, gf, gx)
		return workspace:FindPartOnRay(Ray.new(gv, gw.unit * gf), gx)
	end;
	function PositiveAngle(g4)
		if g4 >= 0 then
			g4 = 0
		end;
		return g4
	end;
	function NegativeAngle(g4)
		if g4 <= 0 then
			g4 = 0
		end;
		return g4
	end;
	function Swait(g4)
		game:GetService("RunService").RenderStepped:Wait()
	end;
	function CreateMesh(ht, ee, hu, hv, hw, hx, hy)
		local hz = IT(ht)
		if ht == "SpecialMesh" then
			hz.MeshType = hu;
			if hv ~= "nil" and hv ~= "" then
				hz.MeshId = "http://www.roblox.com/asset/?id=" .. hv
			end;
			if hw ~= "nil" and hw ~= "" then
				hz.TextureId = "http://www.roblox.com/asset/?id=" .. hw
			end
		end;
		hz.Offset = hy or VT(0, 0, 0)
		hz.Scale = hx;
		hz.Parent = ee;
		return hz
	end;
	function CreatePart(gm, ee, gn, go, gp, gq, gr, gs, gt)
		local gu = IT("Part")
		gu.formFactor = gm;
		gu.Reflectance = go;
		gu.Transparency = gp;
		gu.CanCollide = false;
		gu.Locked = true;
		gu.Anchored = true;
		if gt == false then
			gu.Anchored = false
		end;
		gu.BrickColor = BRICKC(tostring(gq))
		gu.Name = gr;
		gu.Size = gs;
		gu.Position = Torso.Position;
		gu.Material = gn;
		gu:BreakJoints()
		gu.Parent = ee;
		return gu
	end;
	local function hA(a, j)
		local hB = Instance.new("ManualWeld")
		hB.Part0 = a;
		hB.Part1 = j;
		hB.C0 = CFrame.new()
		hB.C1 = j.CFrame:inverse() * a.CFrame;
		hB.Parent = a;
		return hB
	end;
	function QuaternionFromCFrame(cf)
		local ca, cb, cc, cd, ce, cg, ch, ci, cj, ck, cl, cm = cf:components()
		local cn = cd + ci + cm;
		if cn > 0 then
			local am = math.sqrt(1 + cn)
			local co = 0.5 / am;
			return (cl - cj) * co, (cg - ck) * co, (ch - ce) * co, am * 0.5
		else
			local b = 0;
			if ci > cd then
				b = 1
			end;
			if cm > (b == 0 and cd or ci) then
				b = 2
			end;
			if b == 0 then
				local am = math.sqrt(cd - ci - cm + 1)
				local co = 0.5 / am;
				return 0.5 * am, (ch + ce) * co, (ck + cg) * co, (cl - cj) * co
			elseif b == 1 then
				local am = math.sqrt(ci - cm - cd + 1)
				local co = 0.5 / am;
				return (ce + ch) * co, 0.5 * am, (cl + cj) * co, (cg - ck) * co
			elseif b == 2 then
				local am = math.sqrt(cm - cd - ci + 1)
				local co = 0.5 / am;
				return (cg + ck) * co, (cj + cl) * co, 0.5 * am, (ch - ce) * co
			end
		end
	end;
	function QuaternionToCFrame(cp, cq, cr, U, V, aL, cs)
		local ct, cu, cv = U + U, V + V, aL + aL;
		local cw, cx, cy = cs * ct, cs * cu, cs * cv;
		local cz = U * ct;
		local cA = U * cu;
		local cB = U * cv;
		local cC = V * cu;
		local cD = V * cv;
		local cE = aL * cv;
		return CFrame.new(cp, cq, cr, 1 - (cC + cE), cA - cy, cB + cx, cA + cy, 1 - (cz + cE), cD - cw, cB - cx, cD + cw, 1 - (cz + cC))
	end;
	function QuaternionSlerp(a, j, t)
		local cF = a[1] * j[1] + a[2] * j[2] + a[3] * j[3] + a[4] * j[4]
		local cG, cH;
		if cF >= 0.0001 then
			if 1 - cF > 0.0001 then
				local cI = ACOS(cF)
				local cJ = 1 / SIN(cI)
				cG = SIN((1 - t) * cI) * cJ;
				cH = SIN(t * cI) * cJ
			else
				cG = 1 - t;
				cH = t
			end
		else
			if 1 + cF > 0.0001 then
				local cI = ACOS(-cF)
				local cJ = 1 / SIN(cI)
				cG = SIN((t - 1) * cI) * cJ;
				cH = SIN(t * cI) * cJ
			else
				cG = t - 1;
				cH = t
			end
		end;
		return a[1] * cG + j[1] * cH, a[2] * cG + j[2] * cH, a[3] * cG + j[3] * cH, a[4] * cG + j[4] * cH
	end;
	function Clerp(a, j, t)
		local c1 = {
			QuaternionFromCFrame(a)
		}
		local c2 = {
			QuaternionFromCFrame(j)
		}
		local c3, c4, c5 = a.x, a.y, a.z;
		local c6, c7, c8 = j.x, j.y, j.z;
		local c9 = 1 - t;
		return QuaternionToCFrame(c9 * c3 + t * c6, c9 * c4 + t * c7, c9 * c5 + t * c8, QuaternionSlerp(c1, c2, t))
	end;
	function CreateFrame(ee, gp, hC, gv, gs, hs, hD, gr)
		local frame = IT("Frame")
		frame.BackgroundTransparency = gp;
		frame.BorderSizePixel = hC;
		frame.Position = gv;
		frame.Size = gs;
		frame.BackgroundColor3 = hs;
		frame.BorderColor3 = hD;
		frame.Name = gr;
		frame.Parent = ee;
		return frame
	end;
	function CreateLabel(ee, hE, hF, hG, hH, gp, hC, hI, gr)
		local hJ = IT("TextLabel")
		hJ.BackgroundTransparency = 1;
		hJ.Size = UD2(1, 0, 1, 0)
		hJ.Position = UD2(0, 0, 0, 0)
		hJ.TextColor3 = hF;
		hJ.TextStrokeTransparency = hI;
		hJ.TextTransparency = gp;
		hJ.FontSize = hG;
		hJ.Font = hH;
		hJ.BorderSizePixel = hC;
		hJ.TextScaled = false;
		hJ.Text = hE;
		hJ.Name = gr;
		hJ.Parent = ee;
		return hJ
	end;
	function NoOutlines(hr)
		hr.TopSurface, hr.BottomSurface, hr.LeftSurface, hr.RightSurface, hr.FrontSurface, hr.BackSurface = 10, 10, 10, 10, 10, 10
	end;
	function CreateWeld(bC, ag, ah, hK, hL, hM, hN, hO, hP, hQ, hR, hS, hT, hU, hV)
		local hW = Instance.new("Weld")
		hW.Parent = bC;
		hW.Part0 = ag;
		hW.Part1 = ah;
		hW.C1 = CFrame.new(hK, hL, hM) * CFrame.Angles(hN, hO, hP)
		hW.C0 = CFrame.new(hQ, hR, hS) * CFrame.Angles(hT, hU, hV)
		return hW
	end;
	function NewSound(g6)
		local ed = "rbxassetid://" .. (g6.ID or 0)
		local ee = g6.PARENT or RootPart;
		local ef = g6.VOLUME or 0.5;
		local eg = g6.PITCH or 1;
		local g7 = g6.LOOP or false;
		local g8 = g6.MAXDISTANCE or 100;
		local g9 = g6.EMITTERSIZE or 10;
		local ga = g6.PLAYING or true;
		local gb = g6.PLAYONREMOVE or false;
		local gc = g6.DOESDEBRIS or true;
		if ed ~= "rbxassetid://0" then
			local SOUND = IT("Sound", ee)
			SOUND.SoundId = ed;
			SOUND.Volume = ef;
			SOUND.Pitch = eg;
			SOUND.Looped = g7;
			SOUND.MaxDistance = g8;
			SOUND.EmitterSize = g9;
			SOUND.PlayOnRemove = gb;
			if gc == true and ga == true and g7 == false then
				Debris:AddItem(SOUND, SOUND.TimeLength + 5)
			end;
			if ga == true then
				SOUND:Play()
			end;
			return SOUND
		end
	end;
	function CreateWeldOrSnapOrMotor(hX, ee, hY, hZ, dc, dd)
		local h_ = IT(hX)
		h_.Part0 = hY;
		h_.Part1 = hZ;
		h_.C0 = dc;
		h_.C1 = dd;
		h_.Parent = ee;
		return h_
	end;
	local dh = IT("Sound")
	function CreateSound(ed, ee, ef, eg, i0)
		local i1 = nil;
		coroutine.resume(coroutine.create(function()
			i1 = dh:Clone()
			i1.Parent = ee;
			i1.Volume = ef;
			i1.Pitch = eg;
			i1.SoundId = "http://www.roblox.com/asset/?id=" .. ed;
			i1:play()
			if i0 == true then
				i1.Looped = true
			else
				repeat
					wait(1)
				until i1.Playing == false or i1.Parent ~= ee;
				i1:remove()
			end
		end))
		return i1
	end;
	function CFrameFromTopBack(i2, i3, i4)
		local i5 = i3:Cross(i4)
		return CF(i2.x, i2.y, i2.z, i5.x, i3.x, i4.x, i5.y, i3.y, i4.y, i5.z, i3.z, i4.z)
	end;
	function WACKYEFFECT(i6)
		local hX = i6.EffectType or "Sphere"
		local gs = i6.Size or VT(1, 1, 1)
		local i7 = i6.Size2 or VT(0, 0, 0)
		local gp = i6.Transparency or 0;
		local i8 = i6.Transparency2 or 1;
		local i9 = i6.CFrame or Torso.CFrame;
		local ia = i6.MoveToPos or nil;
		local ib = i6.RotationX or 0;
		local ic = i6.RotationY or 0;
		local id = i6.RotationZ or 0;
		local gn = i6.Material or "Neon"
		local hs = i6.Color or C3(1, 1, 1)
		local h3 = i6.Time or 45;
		local ie = i6.SoundID or nil;
		local ig = i6.SoundPitch or nil;
		local ih = i6.SoundVolume or nil;
		coroutine.resume(coroutine.create(function()
			local ii = false;
			local SOUND = nil;
			local ij = CreatePart(3, Effects, gn, 0, gp, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
			if ie ~= nil and ig ~= nil and ih ~= nil then
				ii = true;
				SOUND = CreateSound(ie, ij, ih, ig, false)
			end;
			ij.Color = hs;
			local ik = nil;
			if hX == "Sphere" then
				ik = CreateMesh("SpecialMesh", ij, "Sphere", "", "", gs, VT(0, 0, 0))
			elseif hX == "Block" then
				ik = IT("BlockMesh", ij)
				ik.Scale = VT(gs.X, gs.X, gs.X)
			elseif hX == "Wave" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "20329976", "", gs, VT(0, 0, -gs.X / 8))
			elseif hX == "Ring" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "559831844", "", VT(gs.X, gs.X, 0.1), VT(0, 0, 0))
			elseif hX == "Slash" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "662586858", "", VT(gs.X / 10, 0, gs.X / 10), VT(0, 0, 0))
			elseif hX == "Round Slash" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "662585058", "", VT(gs.X / 10, 0, gs.X / 10), VT(0, 0, 0))
			elseif hX == "Swirl" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "1051557", "", gs, VT(0, 0, 0))
			elseif hX == "Skull" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "4770583", "", gs, VT(0, 0, 0))
			elseif hX == "Crystal" then
				ik = CreateMesh("SpecialMesh", ij, "FileMesh", "9756362", "", gs, VT(0, 0, 0))
			end;
			if ik ~= nil then
				local il = nil;
				if ia ~= nil then
					il = i9.p - ia.Magnitude / h3
				end;
				local im = gs - i7;
				local io = gp - i8;
				if hX == "Block" then
					ij.CFrame = i9 * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				else
					ij.CFrame = i9
				end;
				for g7 = 1, h3 + 1 do
					Swait()
					ik.Scale = ik.Scale - im / h3;
					if hX == "Wave" then
						ik.Offset = VT(0, 0, -ik.Scale.X / 8)
					end;
					ij.Transparency = ij.Transparency - io / h3;
					if hX == "Block" then
						ij.CFrame = i9 * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
					else
						ij.CFrame = ij.CFrame * ANGLES(RAD(ib), RAD(ic), RAD(id))
					end;
					if ia ~= nil then
						local ip = ij.Orientation;
						ij.CFrame = CF(ij.Position, ia) * CF(0, 0, -il)
						ij.Orientation = ip
					end
				end;
				if ii == false then
					ij:remove()
				else
					SOUND.Stopped:Connect(function()
						ij:remove()
					end)
				end
			else
				if ii == false then
					ij:remove()
				else
					repeat
						Swait()
					until SOUND.Playing == false;
					ij:remove()
				end
			end
		end))
	end;
	function MakeForm(hr, hX)
		if hX == "Cyl" then
			local ik = IT("CylinderMesh", hr)
		elseif hX == "Ball" then
			local ik = IT("SpecialMesh", hr)
			ik.MeshType = "Sphere"
		elseif hX == "Wedge" then
			local ik = IT("SpecialMesh", hr)
			ik.MeshType = "Wedge"
		end
	end;
	function SpawnTrail(iq, ir, is)
		local it = CreatePart(3, Effects, "Neon", 0, 0.5, "New Yeller", "Trail", VT(0, 0, 0))
		MakeForm(it, "Cyl")
		local iu = iq - ir.Magnitude;
		if is == true then
			it.Size = VT(0.5, iu, 0.5)
		else
			it.Size = VT(0.25, iu, 0.25)
		end;
		it.CFrame = CF(iq, ir) * CF(0, 0, -iu / 2) * ANGLES(RAD(90), RAD(0), RAD(0))
		coroutine.resume(coroutine.create(function()
			for b = 1, 5 do
				Swait()
				it.Transparency = it.Transparency + 0.1
			end;
			it:remove()
		end))
	end;
	function MagicSphere(gs, iv, i9, hs, iw)
		local ix = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(hs), "Effect", VT(1, 1, 1), true)
		local mesh = IT("SpecialMesh", ix)
		mesh.MeshType = "Sphere"
		mesh.Scale = gs;
		mesh.Offset = VT(0, 0, 0)
		ix.CFrame = i9;
		coroutine.resume(coroutine.create(function(hr)
			for b = 1, iv do
				Swait()
				mesh.Scale = mesh.Scale + iw;
				ix.Transparency = ix.Transparency + 1 / iv;
				if ix.Transparency > 0.99 then
					ix:remove()
				end
			end
		end))
	end;
	function MagicSphereCo(gs, iv, i9, hs, iw)
		local ix = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(hs), "Effect", VT(1, 1, 1), true)
		local mesh = IT("SpecialMesh", ix)
		mesh.MeshType = "Sphere"
		mesh.Scale = gs;
		mesh.Offset = VT(0, 0, 0)
		ix.CFrame = i9;
		coroutine.resume(coroutine.create(function(hr)
			for b = 1, iv do
				Swait()
				mesh.Scale = mesh.Scale + iw;
				ix.Transparency = ix.Transparency + 1 / iv;
				if ix.Transparency > 0.99 then
					ix:remove()
				end
			end
		end))
	end;
	function MagicBlock(gs, iv, i9, hs, iw)
		local ix = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(hs), "Effect", VT(gs, gs, gs), true)
		local mesh = IT("BlockMesh", ix)
		ix.CFrame = i9 * ANGLES(RAD(math.random(-360, 360)), RAD(math.random(-360, 360)), RAD(math.random(-360, 360)))
		coroutine.resume(coroutine.create(function(hr)
			for b = 1, iv do
				Swait()
				mesh.Scale = mesh.Scale + iw;
				ix.CFrame = i9 * ANGLES(RAD(math.random(-360, 360)), RAD(math.random(-360, 360)), RAD(math.random(-360, 360)))
				ix.Transparency = ix.Transparency + 0.5 / iv;
				if ix.Transparency > 0.99 then
					ix:remove()
				end
			end
		end))
	end;
	function CreateRing(gs, iy, iz, iv, i9, hs, iw)
		local ix = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(hs), "Effect", VT(0, 0, 0))
		local mesh = CreateMesh("SpecialMesh", ix, "FileMesh", "559831844", "", gs, VT(0, 0, 0))
		ix.CFrame = i9;
		coroutine.resume(coroutine.create(function(hr)
			for b = 1, iv do
				Swait()
				mesh.Scale = mesh.Scale + iw;
				if iy == true then
					ix.CFrame = ix.CFrame * CFrame.fromEulerAnglesXYZ(0, iz, 0)
				end;
				ix.Transparency = ix.Transparency + 0.5 / iv;
				if ix.Transparency > 0.99 then
					ix:remove()
				end
			end
		end))
	end;
	local iA = IT("Decal")
	function MagicRing()
		local iB = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0, 0, 0), true)
		local ht = IT("BlockMesh", iB)
		local iC = iA:Clone()
		iC.Parent = iB;
		iC.Face = "Bottom"
		iC.Name = "BottomTexture"
		local iD = iA:Clone()
		iD.Parent = iB;
		iD.Face = "Top"
		iD.Name = "TopTexture"
		iC.Texture = "http://www.roblox.com/asset/?id=1208118228"
		iD.Texture = "http://www.roblox.com/asset/?id=1208118228"
		iC.Color3 = C3(0, 0, 0)
		iD.Color3 = C3(1, 1, 1)
		return iB, ht, iD, iC
	end;
	Debris = game:GetService("Debris")
	function CastProperRay(iE, iF, e2, cM)
		local gw = CF(iE, iF).lookVector;
		return Raycast(iE, gw, e2, cM)
	end;
	function turnto(position)
		RootPart.CFrame = CFrame.new(RootPart.CFrame.p, VT(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
	end;
	function SHAKECAM(gv, gf, iG, h3)
		local iH = workspace:GetDescendants()
		for gj, gk in pairs(iH) do
			if gk.ClassName == "Model" then
				local fv = gk:FindFirstChildOfClass("Humanoid")
				if fv then
					local TORSO = gk:FindFirstChild("Torso") or gk:FindFirstChild("UpperTorso")
					if TORSO and gf >= TORSO.Position - gv.Magnitude then
						local iI = script.CamShake:Clone()
						iI.Shake.Value = iG;
						iI.Timer.Value = h3;
						iI.Parent = gk;
						iI.Disabled = false
					end
				end
			end
		end
	end;
	function WWeld(a, j, iJ)
		local iK = Instance.new("Weld", a)
		iK.Part0 = a;
		iK.Part1 = j;
		if iJ ~= nil then
			iK.C0 = iJ
		end
	end;
	for b = 1, 10 do
		wait()
	end;
	TORSO = script.Torso;
	TORSO.Parent = Character;
	WWeld(TORSO.Torso, Torso, CF(0, 0, 0) * ANGLES(RAD(176), RAD(359), RAD(180)), CF(0, 0, 0))
	local iL = script.Tec9:Clone()
	iL.Parent = RightArm;
	for b, v in pairs(iL:GetChildren()) do
		v.Transparency = 1
	end;
	CreateWeld(iL.Handle, RightArm, iL.Handle, -0.3, -0.2, -0.9, math.rad(90), math.rad(0), math.rad(180), 0, 0, 0, math.rad(0), math.rad(0), math.rad(0))
	local iM = iL.Hole;
	game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
	local function af(ag, ah)
		attachment = Instance.new("Attachment", ag)
		attachment.Position = Vector3.new(1, -0.5, -0.3)
		attachment.Orientation = Vector3.new(90, 90, 0)
		attachment02 = Instance.new("Attachment", ah)
		lol = Instance.new("AlignPosition", ag)
		lol.Attachment0 = attachment;
		lol.Attachment1 = attachment02;
		lol.MaxForce = math.huge;
		lol.RigidityEnabled = true;
		pog = Instance.new("AlignOrientation", ag)
		pog.Attachment0 = attachment;
		pog.Attachment1 = attachment02;
		pog.Responsiveness = 20;
		pog.RigidityEnabled = true
	end;
	af(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, game.Players.LocalPlayer.Character["Right Arm"])
	local iN = IT("ParticleEmitter", nil)
	iN.Enabled = false;
	iN.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.3),
		NumberSequenceKeypoint.new(0.3, 0),
		NumberSequenceKeypoint.new(1, 1)
	})
	iN.LightEmission = 0.5;
	iN.Rate = 150;
	iN.ZOffset = 0.2;
	iN.Rotation = NumberRange.new(-180, 180)
	iN.RotSpeed = NumberRange.new(-180, 180)
	iN.Texture = "http://www.roblox.com/asset/?id=304437537"
	iN.Color = ColorSequence.new(C3(1, 1, 1), C3(0, 0, 0))
	function ParticleEmitter(i6)
		local iO = iN:Clone()
		local dx = i6.Speed or 5;
		local dp = i6.Drag or 0;
		local iP = i6.Size1 or 1;
		local iQ = i6.Size2 or 5;
		local iR = i6.Lifetime1 or 1;
		local iS = i6.Lifetime2 or 1.5;
		local cZ = i6.Parent or Torso;
		local iT = i6.Emit or 100;
		local iU = i6.Offset or 360;
		local iV = i6.Acel or VT(0, 0, 0)
		local dt = i6.Enabled or false;
		iO.Parent = cZ;
		iO.Size = NumberSequence.new(iP, iQ)
		iO.Lifetime = NumberRange.new(iR, iS)
		iO.Speed = NumberRange.new(dx)
		iO.VelocitySpread = iU;
		iO.Drag = dp;
		iO.Acceleration = iV;
		if dt == false then
			iO:Emit(iT)
			Debris:AddItem(iO, iS)
		else
			iO.Enabled = true
		end;
		return iO
	end;
	for a3, c in pairs(hl:GetChildren()) do
		if c.ClassName == "Part" then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
	end;
	hl.Parent = Character;
	hk.Parent = Character;
	local iW = C3(1, 1, 1)
	local iX = ""
	local iY = 7;
	local hp = {}
	for a3, c in pairs(Character:GetDescendants()) do
		if c:IsA("BasePart") and c.Name ~= "Handle" then
			if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
				c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end;
			table.insert(hp, {
				c,
				c.Parent,
				c.Material,
				c.Color,
				c.Transparency,
				c.Size,
				c.Name
			})
		elseif c:IsA("JointInstance") or c:IsA("Shirt") or c:IsA("Pants") then
			table.insert(hp, {
				c,
				c.Parent,
				nil,
				nil,
				nil,
				nil,
				nil
			})
		end
	end;
	function refit()
		Character.Parent = workspace;
		Effects.Parent = Character;
		for eH = 1, #hp do
			if hp[eH] ~= nil then
				local hq = hp[eH]
				local hr = hq[1]
				local ee = hq[2]
				local gn = hq[3]
				local hs = hq[4]
				local gp = hq[5]
				local gr = hq[7]
				if hr.ClassName == "Part" and hr ~= RootPart then
					hr.Material = gn;
					hr.Transparency = gp;
					hr.Name = gr
				end;
				if hr.Parent ~= ee then
					if hr.Name == "Head" or hr.Name == "Neck" or hr.Name == "Torso" then
						Humanoid:remove()
					end;
					hr.Parent = ee;
					if hr.Name == "Head" or hr.Name == "Neck" or hr.Name == "Torso" then
						Humanoid = IT("Humanoid", Character)
					end
				end
			end
		end
	end;
	function chatfunc(iZ)
		local i_ = coroutine.wrap(function()
			if Character:FindFirstChild("TalkingBillBoard") ~= nil then
				Character:FindFirstChild("TalkingBillBoard"):destroy()
			end;
			local j0 = Instance.new("BillboardGui", Character)
			j0.Size = UDim2.new(0, 100, 0, 40)
			j0.StudsOffset = Vector3.new(0, 3, 0)
			j0.Adornee = Character.Head;
			j0.Name = "TalkingBillBoard"
			local j1 = Instance.new("TextLabel", j0)
			j1.BackgroundTransparency = 1;
			j1.BorderSizePixel = 0;
			j1.Text = ""
			j1.Font = "SourceSansItalic"
			j1.TextSize = 40;
			j1.TextStrokeTransparency = 0;
			j1.Size = UDim2.new(1, 0, 0.5, 0)
			coroutine.resume(coroutine.create(function()
				while j1 ~= nil do
					Swait()
					j1.Position = UDim2.new(math.random(-.4, .4), math.random(-5, 5), .05, math.random(-5, 5))
					j1.Rotation = math.random(-5, 5)
					j1.TextColor3 = Color3.new(0, 0, 0)
					j1.TextStrokeColor3 = Color3.new(1, 1, 1)
				end
			end))
			for b = 1, string.len(iZ), 1 do
				Swait()
				j1.Text = string.sub(iZ, 1, b)
			end;
			Swait(90)
			for b = 0, 1, .025 do
				Swait()
				j0.ExtentsOffset = Vector3.new(math.random(-b, b), math.random(-b, b), math.random(-b, b))
				j1.TextStrokeTransparency = b;
				j1.TextTransparency = b
			end;
			j0:Destroy()
		end)
		i_()
	end;
	function onChatted(Y)
		chatfunc(Y)
	end;
	Player.Chatted:connect(onChatted)
	function printbye(d3)
		local j2 = {
			"You cannot struggle, ",
			"Your existance is an insult, ",
			"Fade, ",
			"Your existance is not desired, ",
			"You are not permitted here, ",
			"You are not to decide your fate, ",
			"Be gone, ",
			"You are already dead, ",
			"Your live is an anomaly, ",
			"Don't dare to return, ",
			"Why are you resisting, ",
			"You cannot exist here, ",
			"Why are you struggling, ",
			"Your fate was already decided, ",
			"Goodbye, ",
			"You cannot ignore my command, ",
			"You cannot resist my command, ",
			"You already died, "
		}
		chatfunc(j2[MRANDOM(1, #j2)] .. d3 .. ".")
	end;
	workspace.ChildAdded:connect(function(j3)
		for j4 = 1, #ho do
			if ho[j4] ~= nil then
				if j3.Name == ho[j4] then
					coroutine.resume(coroutine.create(function()
						printbye(j3.Name)
						j3:ClearAllChildren()
						Debris:AddItem(j3, 0.0005)
					end))
				end
			end
		end
	end)
	function Banish(j5)
		if j5 then
			coroutine.resume(coroutine.create(function()
				table.insert(ho, j5.Name)
				printbye(j5.Name)
				j5.Archivable = true;
				local j6 = j5:Clone()
				j5:Destroy()
				j6.Parent = Effects;
				j6:BreakJoints()
				local j7 = {
					"Glass",
					"Neon"
				}
				for a3, c in pairs(j6:GetDescendants()) do
					if c:IsA("BasePart") then
						if c.Name == "Torso" or c.Name == "UpperTorso" or c == j6.PrimaryPart then
							CreateSound(340722848, c, 10, 1, false)
						end;
						c.Anchored = true;
						c.Transparency = c.Transparency + 0.2;
						c.Material = j7[MRANDOM(1, 2)]
						c.Color = C3(1, 1, 1)
						if c.ClassName == "MeshPart" then
							c.TextureID = ""
						end;
						if c:FindFirstChildOfClass("SpecialMesh") then
							c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
						end;
						if c:FindFirstChildOfClass("Decal") then
							c:FindFirstChildOfClass("Decal"):remove()
						end;
						c.Name = "Banished"
						c.CanCollide = false
					else
						c:remove()
					end
				end;
				local A = false;
				for b = 1, 35 do
					if A == false then
						A = true
					elseif A == true then
						A = false
					end;
					for a3, c in pairs(j6:GetDescendants()) do
						if c:IsA("BasePart") then
							c.Anchored = true;
							c.Material = j7[MRANDOM(1, 2)]
							c.Transparency = c.Transparency + 0.8 / 35;
							if A == false then
								c.CFrame = c.CFrame * CF(MRANDOM(-45, 45) / 45, MRANDOM(-45, 45) / 45, MRANDOM(-45, 45) / 45)
							elseif A == true then
								c.CFrame = c.CFrame * CF(MRANDOM(-45, 45) / 45, MRANDOM(-45, 45) / 45, MRANDOM(-45, 45) / 45)
							end
						end
					end;
					Swait()
				end;
				j6:remove()
			end))
		end
	end;
	function ApplyAoE(gv, gf, j8)
		return
	end;
	function ManualDamage(Humanoid, j9, ja)
		return
	end;
	local jb = Instance.new("ParticleEmitter")
	jb.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
	jb.LightEmission = .1;
	jb.Texture = "http://www.roblox.com/asset/?ID=291880914"
	aaa = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.6),
		NumberSequenceKeypoint.new(1, 2)
	})
	bbb = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 1),
		NumberSequenceKeypoint.new(0.0636, 0),
		NumberSequenceKeypoint.new(1, 1)
	})
	jb.Transparency = bbb;
	jb.Size = aaa;
	jb.ZOffset = .9;
	jb.Acceleration = Vector3.new(0, -15, 0)
	jb.LockedToPart = false;
	jb.EmissionDirection = "Back"
	jb.Lifetime = NumberRange.new(1, 2)
	jb.Rotation = NumberRange.new(-100, 100)
	jb.RotSpeed = NumberRange.new(-100, 100)
	jb.Speed = NumberRange.new(10)
	jb.Enabled = false;
	jb.VelocitySpread = 999;
	function getbloody(jc, jd)
		local hr = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", jc.Size)
		hr.CFrame = jc.CFrame;
		local je = {
			"356551938",
			"264486467"
		}
		Debris:AddItem(hr, 5)
		CreateSound(je[MRANDOM(1, #je)], hr, 1, math.random(8, 12) / 10)
		CreateSound(je[MRANDOM(1, #je)], hr, 1, math.random(8, 12) / 10)
		CreateSound(je[MRANDOM(1, #je)], hr, 1, math.random(8, 12) / 10)
		local jf = jb:Clone()
		jf.Parent = hr;
		jf:Emit(jd * 10)
	end;
	function ManualAoE(gv, gf, jg, jh, gg, ji)
		local iH = workspace:GetDescendants()
		for gj, gk in pairs(iH) do
			if gk.ClassName == "Model" and gk ~= Character and gk.Parent ~= Effects then
				local fv = gk:FindFirstChildOfClass("Humanoid")
				if fv then
					local TORSO = gk:FindFirstChild("Torso") or gk:FindFirstChild("UpperTorso")
					if TORSO then
						if TORSO.Position - gv.Magnitude <= gf then
							if ji == true then
								gk:BreakJoints()
							else
								local jj = MRANDOM(jg, jh)
								ManualDamage(fv, jj, TORSO)
							end;
							if gg > 0 then
								for a3, c in pairs(gk:GetChildren()) do
									if c:IsA("BasePart") then
										local jk = Instance.new("BodyVelocity")
										jk.maxForce = Vector3.new(1e9, 1e9, 1e9)
										jk.velocity = CF(gv, TORSO.Position).lookVector * gg;
										jk.Parent = c;
										Debris:AddItem(jk, 0.05)
									end
								end
							end
						end
					end
				end
			end
		end
	end;
	function Dismember(gd, jl)
		for gj, gk in pairs(gd:GetDescendants()) do
			if gk:IsA("Script") or gk:IsA("LocalScript") then
				gk:Destroy()
			end
		end;
		if jl == "Ragdoll" then
			local fv = gd:FindFirstChildOfClass("Humanoid")
			if fv then
				fv.Health = 0
			end;
			if gd:FindFirstChild("UpperTorso") then
				local jm = script.R15Ragdoll:Clone()
				jm.Parent = gd;
				jm.Disabled = false
			else
				local jm = script.R6Ragdoll:Clone()
				jm.Parent = gd;
				jm.Disabled = false
			end;
			gd:BreakJoints()
		else
			local TORSO = gd:FindFirstChild("Torso") or gd:FindFirstChild("UpperTorso")
			local jn = gd:FindFirstChild("Head")
			if TORSO and jn then
				if jl == "Head" then
					if TORSO:FindFirstChild("TorsoA4") then
						TORSO:FindFirstChild("TorsoA4"):Remove()
					elseif gd:FindFirstChild("RagdollConstraintHead") then
						gd:FindFirstChild("RagdollConstraintHead"):Remove()
					end;
					jn:BreakJoints()
				elseif jl == "RightArm" then
					if TORSO:FindFirstChild("TorsoA3") then
						TORSO:FindFirstChild("TorsoA3"):Remove()
					elseif gd:FindFirstChild("RagdollConstraintRightUpperArm") then
						gd:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
					end
				elseif jl == "LeftArm" then
					if TORSO:FindFirstChild("TorsoA2") then
						TORSO:FindFirstChild("TorsoA2")
					elseif gd:FindFirstChild("RagdollConstraintLeftUpperArm") then
						gd:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
					end
				elseif jl == "Legs" then
					if TORSO.Name == "Torso" then
						if TORSO:FindFirstChild("TorsoA") then
							TORSO:FindFirstChild("TorsoA"):Remove()
						end;
						if TORSO:FindFirstChild("TorsoA1") then
							TORSO:FindFirstChild("TorsoA1"):Remove()
						end
					elseif gd:FindFirstChild("RagdollConstraintUpperTorso") then
						gd:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
					end
				end
			end
		end
	end;
	function AttachmentCFrame(A)
		return A.Parent.CFrame * CF(A.Position)
	end;
	function R15Ragdoll(jo, jp)
		jo:BreakJoints()
		coroutine.resume(coroutine.create(function()
			recurse(jo, function(a3, v)
				if v:IsA("Attachment") then
					v.Axis = Vector3.new(0, 1, 0)
					v.SecondaryAxis = Vector3.new(0, 0, 1)
					v.Rotation = Vector3.new(0, 0, 0)
				end
			end)
			for a3, jq in next, jo:GetChildren() do
				if jq:IsA("Accoutrement") then
					for a3, part in next, jq:GetChildren() do
						if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
							local jr = part:FindFirstChildOfClass("Attachment")
							local js = getAttachment0(jo, jr.Name)
							if js and jr then
								local jt = Instance.new("HingeConstraint")
								jt.Attachment0 = js;
								jt.Attachment1 = jr;
								jt.LimitsEnabled = true;
								jt.UpperAngle = 0;
								jt.LowerAngle = 0;
								jt.Parent = jo
							end;
							ArtificialHitbox(part)
						elseif part.Name == "HumanoidRootPart" then
							part:remove()
						end
					end
				end
			end;
			ragdollJoint(jo, jo.LowerTorso, jo.UpperTorso, "Waist", "BallSocket", {
				{
					"LimitsEnabled",
					true
				},
				{
					"UpperAngle",
					5
				}
			})
			if jo:FindFirstChild("Head") then
				ragdollJoint(jo, jo.UpperTorso, jo.Head, "Neck", "BallSocket", {
					{
						"LimitsEnabled",
						true
					},
					{
						"UpperAngle",
						15
					}
				})
			end;
			local ju = {
				{
					"LimitsEnabled",
					true
				},
				{
					"UpperAngle",
					0
				},
				{
					"LowerAngle",
					0
				}
			}
			ragdollJoint(jo, jo.LeftLowerArm, jo.LeftHand, "LeftWrist", "Hinge", ju)
			ragdollJoint(jo, jo.RightLowerArm, jo.RightHand, "RightWrist", "Hinge", ju)
			local jv = {
				{
					"LimitsEnabled",
					true
				},
				{
					"UpperAngle",
					0
				},
				{
					"LowerAngle",
					-75
				}
			}
			ragdollJoint(jo, jo.LeftUpperLeg, jo.LeftLowerLeg, "LeftKnee", "Hinge", jv)
			ragdollJoint(jo, jo.RightUpperLeg, jo.RightLowerLeg, "RightKnee", "Hinge", jv)
			local jw = {
				{
					"LimitsEnabled",
					true
				},
				{
					"UpperAngle",
					15
				},
				{
					"LowerAngle",
					-45
				}
			}
			ragdollJoint(jo, jo.LeftLowerLeg, jo.LeftFoot, "LeftAnkle", "Hinge", jw)
			ragdollJoint(jo, jo.RightLowerLeg, jo.RightFoot, "RightAnkle", "Hinge", jw)
			if jp == true then
				ragdollJoint(jo, jo.UpperTorso, jo.RightUpperArm, "RightShoulder", "BallSocket")
				ragdollJoint(jo, jo.RightUpperArm, jo.RightLowerArm, "RightElbow", "BallSocket")
				ragdollJoint(jo, jo.UpperTorso, jo.LeftUpperArm, "LeftShoulder", "BallSocket")
				ragdollJoint(jo, jo.LeftUpperArm, jo.LeftLowerArm, "LeftElbow", "BallSocket")
			end;
			ragdollJoint(jo, jo.LowerTorso, jo.LeftUpperLeg, "LeftHip", "BallSocket")
			ragdollJoint(jo, jo.LowerTorso, jo.RightUpperLeg, "RightHip", "BallSocket")
			Debris:AddItem(jo, 5)
		end))
	end;
	function Ragdoll(jx, jy, jp)
		coroutine.resume(coroutine.create(function()
			jx:BreakJoints()
			local hum = jx:findFirstChild("Humanoid")
			hum:remove()
			local function jz(ay)
				local eH;
				for eH = 1, #ay do
					jz(ay[eH]:GetChildren())
					if ay[eH].ClassName == "Weld" or ay[eH].ClassName == "Motor6D" then
						ay[eH]:remove()
					end
				end
			end;
			local jA = IT("Humanoid")
			jA.Name = "Corpse"
			jA.Health = 0;
			jA.MaxHealth = 0;
			jA.PlatformStand = true;
			jA.Parent = jx;
			jA.DisplayDistanceType = "None"
			local ay = jx:GetChildren()
			local b;
			for b = 1, #ay do
				if ay[b].Name == "THandle1" or ay[b].Name == "THandle2" then
					ay[b]:remove()
				end
			end;
			local jB = jx.Torso;
			local jC = Vector3.new()
			if jB then
				jC = CFrame.new(jy.Position, jB.Position).lookVector;
				local Head = jx:FindFirstChild("Head")
				if Head then
					local Neck = Instance.new("Weld")
					Neck.Name = "Neck"
					Neck.Part0 = jB;
					Neck.Part1 = Head;
					Neck.C0 = CFrame.new(0, 1.5, 0)
					Neck.C1 = CFrame.new()
					Neck.Parent = jB
				end;
				local jD = jx:FindFirstChild("Right Arm")
				if jD and jp == true then
					jD.CFrame = jB.CFrame * CFrame.new(1.5, 0, 0)
					local jE = Instance.new("Glue")
					jE.Name = "RightShoulder"
					jE.Part0 = jB;
					jE.Part1 = jD;
					jE.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					jE.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					jE.Parent = jB;
					local B = Instance.new("Part")
					B.TopSurface = 0;
					B.BottomSurface = 0;
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1;
					B.CFrame = jD.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = jx;
					local jF = Instance.new("Weld")
					jF.Part0 = jD;
					jF.Part1 = B;
					jF.C0 = CFrame.new(0, -0.5, 0)
					jF.Parent = jD
				end;
				local jD = jx:FindFirstChild("Left Arm")
				if jD and jp == true then
					jD.CFrame = jB.CFrame * CFrame.new(-1.5, 0, 0)
					local jE = Instance.new("Glue")
					jE.Name = "LeftShoulder"
					jE.Part0 = jB;
					jE.Part1 = jD;
					jE.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					jE.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					jE.Parent = jB;
					local B = Instance.new("Part")
					B.TopSurface = 0;
					B.BottomSurface = 0;
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1;
					B.CFrame = jD.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = jx;
					local jF = Instance.new("Weld")
					jF.Part0 = jD;
					jF.Part1 = B;
					jF.C0 = CFrame.new(0, -0.5, 0)
					jF.Parent = jD
				end;
				local jD = jx:FindFirstChild("Right Leg")
				if jD then
					jD.CFrame = jB.CFrame * CFrame.new(0.5, -2, 0)
					local jE = Instance.new("Glue")
					jE.Name = "RightHip"
					jE.Part0 = jB;
					jE.Part1 = jD;
					jE.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					jE.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
					jE.Parent = jB;
					local B = Instance.new("Part")
					B.TopSurface = 0;
					B.BottomSurface = 0;
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1;
					B.CFrame = jD.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = jx;
					local jF = Instance.new("Weld")
					jF.Part0 = jD;
					jF.Part1 = B;
					jF.C0 = CFrame.new(0, -0.5, 0)
					jF.Parent = jD
				end;
				local jD = jx:FindFirstChild("Left Leg")
				if jD then
					jD.CFrame = jB.CFrame * CFrame.new(-0.5, -2, 0)
					local jE = Instance.new("Glue")
					jE.Name = "LeftHip"
					jE.Part0 = jB;
					jE.Part1 = jD;
					jE.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					jE.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
					jE.Parent = jB;
					local B = Instance.new("Part")
					B.TopSurface = 0;
					B.BottomSurface = 0;
					B.formFactor = "Symmetric"
					B.Size = Vector3.new(1, 1, 1)
					B.Transparency = 1;
					B.CFrame = jD.CFrame * CFrame.new(0, -0.5, 0)
					B.Parent = jx;
					local jF = Instance.new("Weld")
					jF.Part0 = jD;
					jF.Part1 = B;
					jF.C0 = CFrame.new(0, -0.5, 0)
					jF.Parent = jD
				end;
				local jG = Instance.new("Part")
				jG.TopSurface = 0;
				jG.BottomSurface = 0;
				jG.formFactor = "Symmetric"
				jG.Size = Vector3.new(1, 1, 1)
				jG.Transparency = 1;
				jG.CFrame = jB.CFrame * CFrame.new(0, 0.5, 0)
				jG.Parent = jx;
				local Weld = Instance.new("Weld")
				Weld.Part0 = jB;
				Weld.Part1 = jG;
				Weld.C0 = CFrame.new(0, 0.5, 0)
				Weld.Parent = jB
			end;
			jx.Parent = workspace;
			Debris:AddItem(jx, 5)
			return jx, jB
		end))
	end;
	function KickThatNigga(ft)
		g = game.Players:GetPlayers()
		local jH = IT("Folder", Effects)
		local jI = Instance.new("BillboardGui", jH)
		jI.AlwaysOnTop = false;
		jI.Size = UDim2.new(5, 35, 2, 35)
		jI.StudsOffset = Vector3.new(0, 1, 0)
		jI.Name = "Mark"
		local jJ = Instance.new("TextLabel", jI)
		jJ.BackgroundTransparency = 1;
		jJ.TextScaled = true;
		jJ.BorderSizePixel = 0;
		jJ.Text = ""
		jJ.Font = "SciFi"
		jJ.TextSize = 30;
		jJ.TextStrokeTransparency = 1;
		jJ.TextColor3 = Color3.new(1, 0, 0)
		jJ.TextStrokeColor3 = Color3.new(1, 0, 0)
		jJ.Size = UDim2.new(1, 0, 0.5, 0)
		jJ.Parent = jI;
		CreateSound("527749592", ft, 600, 1, false)
		for b, v in ipairs(ft:GetChildren()) do
			if v.ClassName == "Part" or v.ClassName == "MeshPart" then
				if v.Name ~= "HumanoidRootPart" then
					local jK = v:Clone()
					jK.CanCollide = false;
					jK.Anchored = true;
					jK.CFrame = v.CFrame;
					jK.Parent = jH;
					jK.Material = "Granite"
					jK.Color = C3(.3, 0, 0)
					if jK:FindFirstChildOfClass("Decal") then
						jK:FindFirstChildOfClass("Decal"):remove()
					end;
					if jK.Name == "Head" then
						jI.Adornee = jK
					end;
					if jK.ClassName == "MeshPart" then
						jK.TextureID = ""
					end
				end
			end
		end;
		if ft ~= Character then
			ft:remove()
		end;
		if ft.Name == "Helkern" then
			Character:BreakJoints()
		end;
		coroutine.resume(coroutine.create(function()
			for b = 1, 50 do
				Swait()
				for b, v in ipairs(jH:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 1
					end;
					jI.Enabled = false
				end;
				Swait()
				for b, v in ipairs(jH:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 0
					end;
					jI.Enabled = true
				end
			end;
			jH:remove()
		end))
	end;
	function ApplyAoE(gv, gf, jL)
		local iH = workspace:GetDescendants()
		for gj, gk in pairs(iH) do
			if gk.ClassName == "Model" and gk ~= Character then
				local fv = gk:FindFirstChildOfClass("Humanoid")
				if fv then
					local TORSO = gk:FindFirstChild("Torso") or gk:FindFirstChild("UpperTorso")
					if TORSO then
						if TORSO.Position - gv.Magnitude <= gf then
							if jL == true then
								KickThatNigga(gk)
							else
								if jL == "Gravity" then
									fv.PlatformStand = true;
									if TORSO:FindFirstChild("V3BanishForce" .. Player.Name) then
										local jM = Instance.new("BodyPosition", TORSO)
										jM.D = 15;
										jM.P = 20000;
										jM.maxForce = Vector3.new(math.huge, math.huge, math.huge)
										jM.position = TORSO.Position;
										jM.Name = "V3BanishForce" .. Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce" .. Player.Name).position = TORSO.Position + VT(0, 0.3, 0)
										TORSO.RotVelocity = VT(MRANDOM(-25, 25), MRANDOM(-25, 25), MRANDOM(-25, 25))
									end
								else
									fv.PlatformStand = false
								end
							end
						elseif jL == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce" .. Player.Name) then
								TORSO:FindFirstChild("V3BanishForce" .. Player.Name):remove()
								fv.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end;
	local jN = {}
	function Ban(jO)
		if jO then
			g = game.Players:GetPlayers()
			local jH = IT("Folder", Effects)
			local jI = Instance.new("BillboardGui", jH)
			jI.AlwaysOnTop = false;
			jI.Size = UDim2.new(5, 35, 2, 35)
			jI.StudsOffset = Vector3.new(0, 1, 0)
			jI.Name = "Mark"
			local jJ = Instance.new("TextLabel", jI)
			jJ.BackgroundTransparency = 1;
			jJ.TextScaled = true;
			jJ.BorderSizePixel = 0;
			jJ.Text = ""
			jJ.Font = "SciFi"
			jJ.TextSize = 30;
			jJ.TextStrokeTransparency = 0;
			jJ.TextColor3 = Color3.new(1, 0, 0)
			jJ.TextStrokeColor3 = Color3.new(1, 0, 0)
			jJ.Size = UDim2.new(1, 0, 0.5, 0)
			jJ.Parent = jI;
			local jP = game:GetService("Players")
			local jQ = jP:FindFirstChild(jO.Name)
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild(jO.Name) then
				jQ:Kick(hc)
			end;
			if jP:FindFirstChild("Drago_TH") then
			end;
			table.insert(jN, jO.name)
			coroutine.resume(coroutine.create(function()
				for b = 1, 50 do
					Swait()
					for b, v in ipairs(jH:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 1
						end;
						jI.Enabled = false
					end;
					Swait()
					for b, v in ipairs(jH:GetChildren()) do
						if v.ClassName == "Part" or v.ClassName == "MeshPart" then
							v.Transparency = 0
						end;
						jI.Enabled = true
					end
				end;
				jH:remove()
			end))
		end
	end;
	local function jR(a9)
		for b = 1, #jN do
			if a9.Name == jN[b] then
				a9:Kick("Ur mom gay skids")
			end
		end
	end;
	game.Players.PlayerAdded:connect(function()
		for b, v in pairs(game.Players:GetPlayers()) do
			jR(v)
		end
	end)
	function Kick(jO)
		g = game.Players:GetPlayers()
		local jH = IT("Folder", Effects)
		local jI = Instance.new("BillboardGui", jH)
		jI.AlwaysOnTop = false;
		jI.Size = UDim2.new(5, 35, 2, 35)
		jI.StudsOffset = Vector3.new(0, 1, 0)
		jI.Name = "Mark"
		local jJ = Instance.new("TextLabel", jI)
		jJ.BackgroundTransparency = 1;
		jJ.TextScaled = true;
		jJ.BorderSizePixel = 0;
		jJ.Text = ""
		jJ.Font = "SciFi"
		jJ.TextSize = 30;
		jJ.TextStrokeTransparency = 0;
		jJ.TextColor3 = Color3.new(1, 0, 0)
		jJ.TextStrokeColor3 = Color3.new(1, 0, 0)
		jJ.Size = UDim2.new(1, 0, 0.5, 0)
		jJ.Parent = jI;
		local jP = game:GetService("Players")
		local jQ = jP:FindFirstChild(jO.Name)
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		if jP:FindFirstChild(jO.Name) then
			jQ:Kick(hc)
		end;
		coroutine.resume(coroutine.create(function()
			for b = 1, 50 do
				Swait()
				for b, v in ipairs(jH:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 1
					end;
					jI.Enabled = false
				end;
				Swait()
				for b, v in ipairs(jH:GetChildren()) do
					if v.ClassName == "Part" or v.ClassName == "MeshPart" then
						v.Transparency = 0
					end;
					jI.Enabled = true
				end
			end;
			jH:remove()
		end))
	end;
	function ApplyAoE(gv, gf, j8)
		local iH = workspace:GetDescendants()
		for gj, gk in pairs(iH) do
			if gk.ClassName == "Model" and gk ~= Character then
				local fv = gk:FindFirstChildOfClass("Humanoid")
				if fv then
					local TORSO = gk:FindFirstChild("Torso") or gk:FindFirstChild("UpperTorso")
					if TORSO then
						if TORSO.Position - gv.Magnitude <= gf then
							if j8 == true then
								Banish(gk)
							else
								if j8 == "Gravity" then
									fv.PlatformStand = true;
									if TORSO:FindFirstChild("V3BanishForce" .. Player.Name) then
										local jM = Instance.new("BodyPosition", TORSO)
										jM.D = 15;
										jM.P = 20000;
										jM.maxForce = Vector3.new(math.huge, math.huge, math.huge)
										jM.position = TORSO.Position;
										jM.Name = "V3BanishForce" .. Player.Name
									else
										TORSO:FindFirstChild("V3BanishForce" .. Player.Name).position = TORSO.Position + VT(0, 0.3, 0)
										TORSO.RotVelocity = VT(MRANDOM(-25, 25), MRANDOM(-25, 25), MRANDOM(-25, 25))
									end
								else
									fv.PlatformStand = false
								end
							end
						elseif j8 == "Gravity" then
							if TORSO:FindFirstChild("V3BanishForce" .. Player.Name) then
								TORSO:FindFirstChild("V3BanishForce" .. Player.Name):remove()
								fv.PlatformStand = false
							end
						end
					end
				end
			end
		end
	end;
	function KickAoE(gv, gf, jS)
		local iH = workspace:GetDescendants()
		for gj, gk in pairs(iH) do
			if gk.ClassName == "Model" and gk ~= Character then
				local fv = gk:FindFirstChildOfClass("Humanoid")
				if fv then
					local TORSO = gk:FindFirstChild("Torso") or gk:FindFirstChild("UpperTorso")
					if TORSO then
						if TORSO.Position - gv.Magnitude <= gf then
							if jS == true then
								if dJ == "Banish" then
									KickThatNigger(gk)
								elseif dJ == "Ban" then
									Ban(gk)
								elseif dJ == "Kick" then
									Kick(gk)
								end
							else
								gk:BreakJoints()
							end
						end
					end
				end
			end
		end
	end;
	local jT = Instance.new("ParticleEmitter", art)
	jT.LightEmission = .8;
	jT.Color = ColorSequence.new(BRICKC("Really red").Color)
	jT.Lifetime = NumberRange.new(0.35, 1.5)
	jT.Rotation = NumberRange.new(0, 360)
	jT.Rate = 999;
	jT.VelocitySpread = 10000;
	jT.Acceleration = Vector3.new(0, 0, 0)
	jT.Drag = 5;
	jT.Speed = NumberRange.new(0, 0, 0)
	jT.Texture = "http://www.roblox.com/asset/?id=833874434"
	jT.ZOffset = -1.5;
	jT.Name = "PE"
	jT.Enabled = false;
	function particles(art)
		local jU = jT:Clone()
		jU.Parent = art
	end;
	function KillChildren(v)
		v:BreakJoints()
		for a3, c in pairs(v:GetChildren()) do
			if c.ClassName == "Part" or c.ClassName == "MesPart" then
				if c.Transparency < 1 then
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end;
					particles(c)
					c.PE.Enabled = true;
					c.Parent = Effects;
					c.CanCollide = false;
					c.Material = "Neon"
					c.Color = C3(1, 0, 0)
					c.Transparency = 0.5;
					local jM = Instance.new("BodyPosition", c)
					jM.P = 20000;
					jM.maxForce = Vector3.new(math.huge, math.huge, math.huge)
					jM.position = c.Position + VT(MRANDOM(-0.1, 0.1), MRANDOM(-0.1, 0.1), MRANDOM(-0.1, 0.1))
					jM.Name = "GravityForce"
					coroutine.resume(coroutine.create(function()
						for b = 1, 50 do
							Swait()
							c.Transparency = c.Transparency + 0.01
						end;
						c.PE.Enabled = false;
						Debris:AddItem(c, 2)
					end))
				end
			end
		end
	end;
	function killnearest(position, jV)
		for b, v in ipairs(workspace:GetChildren()) do
			local jW = v:GetChildren()
			for part = 1, #jW do
				if (jW[part].ClassName == "Part" or jW[part].ClassName == "MeshPart") and v ~= Character then
					if jW[part].Position - position.Magnitude < jV then
						if v.ClassName == "Model" then
							KillChildren(v)
						end
					end
				end
			end
		end
	end;
	function Dismember(gd, jl)
		for gj, gk in pairs(gd:GetDescendants()) do
			if gk:IsA("Script") or gk:IsA("LocalScript") then
				gk:Destroy()
			end
		end;
		if jl == "Ragdoll" then
			local fv = gd:FindFirstChildOfClass("Humanoid")
			if fv then
				fv.Health = 0
			end;
			if gd:FindFirstChild("UpperTorso") then
				local jm = script.R15Ragdoll:Clone()
				jm.Parent = gd;
				jm.Disabled = false
			else
				local jm = script.R6Ragdoll:Clone()
				jm.Parent = gd;
				jm.Disabled = false
			end;
			gd:BreakJoints()
		else
			local TORSO = gd:FindFirstChild("Torso") or gd:FindFirstChild("UpperTorso")
			local jn = gd:FindFirstChild("Head")
			if TORSO and jn then
				if jl == "Head" then
					if TORSO:FindFirstChild("TorsoA4") then
						TORSO:FindFirstChild("TorsoA4"):Remove()
					elseif gd:FindFirstChild("RagdollConstraintHead") then
						gd:FindFirstChild("RagdollConstraintHead"):Remove()
					end;
					jn:BreakJoints()
				elseif jl == "RightArm" then
					if TORSO:FindFirstChild("TorsoA3") then
						TORSO:FindFirstChild("TorsoA3"):Remove()
					elseif gd:FindFirstChild("RagdollConstraintRightUpperArm") then
						gd:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
					end
				elseif jl == "LeftArm" then
					if TORSO:FindFirstChild("TorsoA2") then
						TORSO:FindFirstChild("TorsoA2")
					elseif gd:FindFirstChild("RagdollConstraintLeftUpperArm") then
						gd:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
					end
				elseif jl == "Legs" then
					if TORSO.Name == "Torso" then
						if TORSO:FindFirstChild("TorsoA") then
							TORSO:FindFirstChild("TorsoA"):Remove()
						end;
						if TORSO:FindFirstChild("TorsoA1") then
							TORSO:FindFirstChild("TorsoA1"):Remove()
						end
					elseif gd:FindFirstChild("RagdollConstraintUpperTorso") then
						gd:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
					end
				end
			end
		end
	end;
	function ManSlaughter(gd)
	end;
	function ApplyDamage2(Humanoid, j9, jX)
	end;
	function BulletDetection(iq, ir, jS)
		local jY, jZ, j_ = CastProperRay(iq, ir, 2000, Character)
		coroutine.resume(coroutine.create(function()
			if jY ~= nil then
				if jY.Parent ~= Character then
					if jY.Parent:FindFirstChildOfClass("Humanoid") or jY.Parent.Parent:FindFirstChildOfClass("Humanoid") then
						if jY.Parent:FindFirstChildOfClass("Humanoid") then
							if jS == true then
								ApplyDamage2(jY.Parent:FindFirstChildOfClass("Humanoid"), 999, true)
							else
								getbloody(jY, 3)
								jY.Parent:BreakJoints()
								if jY.Name == "Head" then
									jY.Name = "HEADSHOT"
									jY:remove()
								end
							end
						else
							if jS == true then
								ApplyDamage2(jY.Parent.Parent:FindFirstChildOfClass("Humanoid"), 999, true)
							else
								jY.Parent.Parent:BreakJoints()
							end
						end
					end
				end
			end
		end))
		SpawnTrail(iq, jZ)
		return jY, jZ, j_
	end;
	function Bomb()
		local h0, k0, j_ = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
		if eP.Target.Parent ~= Character and eP.Target.Parent.Parent ~= Character and eP.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
			local fv = eP.Target.Parent:FindFirstChildOfClass("Humanoid")
			local TORSO = fv.Parent:FindFirstChild("Torso") or fv.Parent:FindFirstChild("UpperTorso")
			if TORSO and fv.Health > 0 then
				h6 = true;
				hd = false;
				local gM = IT("BodyGyro", RootPart)
				gM.D = 275;
				gM.P = 20000;
				gM.MaxTorque = VT(0, 40000, 0)
				local jM = Instance.new("BodyPosition", TORSO)
				jM.D = 1500;
				jM.P = 20000;
				jM.maxForce = Vector3.new(math.huge, math.huge, math.huge)
				jM.position = TORSO.Position + VT(0, 0, 0)
				CreateSound(429459101, TORSO, 0.5, 1, false)
				for b = 0, 4, 0.1 / Animation_Speed do
					Swait()
					gM.cframe = CF(RootPart.Position, TORSO.Position)
					WACKYEFFECT({
						Time = 12,
						EffectType = "Block",
						Size = VT(0, 0, 0),
						Size2 = VT(1, 1, 1),
						Transparency = 0,
						Transparency2 = 1,
						CFrame = LeftArm.CFrame * CF(0, -1.5, 0),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Neon",
						Color = C3(1, 0, 0),
						SoundID = 0,
						SoundPitch = 2,
						SoundVolume = 0.8
					})
					RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(MRANDOM(-10, 10)), RAD(65)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * fZ, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(MRANDOM(-15, 15)), RAD(-90)) * f_, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end;
				SHAKECAM(k0, 15, 2, 130)
				CreateSound(884348443, TORSO, 5, 0.8, false)
				killnearest(TORSO.Position, 5, 5)
				for b = 0, 1, 0.1 / Animation_Speed do
					Swait()
					WACKYEFFECT({
						Time = 12,
						EffectType = "Block",
						Size = VT(0, 0, 0),
						Size2 = VT(1, 1, 1),
						Transparency = 0,
						Transparency2 = 1,
						CFrame = LeftArm.CFrame * CF(0, -1.5, 0),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Neon",
						Color = C3(1, 0, 0),
						SoundID = 0,
						SoundPitch = 2,
						SoundVolume = 0.8
					})
					RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(MRANDOM(-10, 10)), RAD(65)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * fZ, 0.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(160), RAD(MRANDOM(-15, 15)), RAD(-70)) * f_, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				end;
				gM:Remove()
				h6 = false;
				hd = false
			end
		end
	end;
	function Bomb2()
		local k1 = eP.Target;
		if k1 ~= nil then
			if k1.Parent:FindFirstChildOfClass("Humanoid") then
				local fv = k1.Parent:FindFirstChildOfClass("Humanoid")
				local fx = k1.Parent:FindFirstChild("HumanoidRootPart") or k1.Parent:FindFirstChild("Torso") or k1.Parent:FindFirstChild("UpperTorso")
				if fx and fv.Health > 0 then
					local k2 = eP.Target.Parent;
					RootPart.CFrame = fx.CFrame * CF(0, 0, 4.2)
					fx.Anchored = true;
					local h0, k0, j_ = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
					if eP.Target.Parent ~= Character and eP.Target.Parent.Parent ~= Character and eP.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						local fv = eP.Target.Parent:FindFirstChildOfClass("Humanoid")
						local TORSO = fv.Parent:FindFirstChild("Torso") or fv.Parent:FindFirstChild("UpperTorso")
						if TORSO and fv.Health > 0 then
							h6 = true;
							hd = true;
							hd = true;
							for b = 0, 3, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 15)) * ANGLES(RAD(0), RAD(0), RAD(65)), 0.5 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(0), RAD(65)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * fZ, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * f_, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end;
							local h0, k0, j_ = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
							local iH = workspace:GetDescendants()
							for gj, gk in pairs(iH) do
								if gk.ClassName == "Model" and gk ~= Character then
									local fv = gk:FindFirstChildOfClass("Humanoid")
									if fv then
										local TORSO = gk:FindFirstChild("Head")
										if TORSO then
											if TORSO.Position - RootPart.Position.Magnitude <= 7 then
												getbloody(TORSO, 5)
												SHAKECAM(k0, 15, 2, 130)
												TORSO:remove()
												if gk:FindFirstChild("Torso") then
													Ragdoll(gk, Torso, true)
												elseif gk:FindFirstChild("UpperTorso") then
													R15Ragdoll(gk, true)
												end
											end
										end
									end
								end
							end;
							CreateSound(887549720, TORSO, 5, 1, false)
							for b = 0, 1, 0.1 / Animation_Speed do
								Swait()
								RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 15)) * ANGLES(RAD(0), RAD(0), RAD(-90)), 1 / Animation_Speed)
								Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(0), RAD(120)), 1 / Animation_Speed)
								RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * fZ, 0.5 / Animation_Speed)
								LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * f_, 1 / Animation_Speed)
								RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
								LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 15), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
							end;
							h6 = false;
							hd = false
						end
					end
				end
			end
		end
	end;
	function Taunt()
		h6 = true;
		hd = true;
		CreateSound(967069404, Head, 10, 0.9, false)
		for b = 0, 4, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 2)) * ANGLES(RAD(10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(COS(10 * fV / 2)), RAD(0)) * fZ, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(COS(-10 * fV / 2)), RAD(COS(-10 * fV / 2)), RAD(-8)) * f_, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 2), -0.01) * ANGLES(RAD(10), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 2), -0.01) * ANGLES(RAD(10), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end;
		h6 = false;
		hd = false
	end;
	function Zone()
		h6 = true;
		hd = true;
		local gM = IT("BodyGyro", nil)
		gM.D = 175;
		gM.P = 20000;
		gM.MaxTorque = VT(0, 40000, 0)
		gM.cframe = CF(RootPart.Position, eP.Hit.p)
		for b = 0, 0.7, 0.1 / Animation_Speed do
			Swait()
			gM.cframe = CF(RootPart.Position, eP.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * fZ, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-15)) * f_, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end;
		for b = 0, 0.7, 0.1 / Animation_Speed do
			Swait()
			gM.cframe = CF(RootPart.Position, eP.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * fZ, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(30)) * f_, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end;
		CreateSound(317130715, iM, 7, 1.3, false)
		for b = 0, 0.7, 0.1 / Animation_Speed do
			Swait()
			gM.cframe = CF(RootPart.Position, eP.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * fZ, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(50)) * f_, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end;
		repeat
			for b = 0, 0.1, 0.1 / Animation_Speed do
				Swait()
				gM.cframe = CF(RootPart.Position, eP.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(MRANDOM(-10, 10)), RAD(35)) * fZ, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * f_, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end;
			local h0, k0, j_ = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
			BulletDetection(iM.Position, eP.Hit.p, true)
			local gi, gP = CastProperRay(AttachmentCFrame(iM.Nuzzle).p, fJ, 1000, Character)
			local k3 = gP - AttachmentCFrame(iM.Nuzzle).p.Magnitude;
			WACKYEFFECT({
				Time = 12,
				EffectType = "Block",
				Size = VT(0, 0, 0),
				Size2 = VT(0.8, 0.8, 0.8),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = CF(AttachmentCFrame(iM.Nuzzle).p),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Glass",
				Color = C3(1, 1, 0),
				SoundID = 745308042,
				SoundPitch = 2,
				SoundVolume = 0.8
			})
			WACKYEFFECT({
				Time = 8,
				EffectType = "Box",
				Size = VT(0, 0, k3),
				Size2 = VT(0.1, 0.1, k3),
				Transparency = 0,
				Transparency2 = 1,
				CFrame = CF(AttachmentCFrame(iM.Nuzzle).p, gP) * CF(0, 0, -k3 / 2),
				MoveToPos = nil,
				RotationX = 0,
				RotationY = 0,
				RotationZ = 0,
				Material = "Glass",
				Color = C3(1, 1, 0),
				SoundID = nil,
				SoundPitch = nil,
				SoundVolume = nil
			})
			SHAKECAM(k0, 3, 3, 3)
			for b = 0, 0.08, 0.1 / Animation_Speed do
				Swait()
				gM.cframe = CF(RootPart.Position, eP.Hit.p)
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.3) * ANGLES(RAD(100), RAD(MRANDOM(-10, 10)), RAD(35)) * fZ, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * f_, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		until fT == false;
		for b = 0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(35)) * fZ, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * f_, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		end;
		gM:Remove()
		h6 = false;
		hd = false
	end;
	Humanoid.Animator.Parent = nil;
	function MouseDown(eP)
		if h6 == false then
		end
	end;
	function MouseUp(eP)
		ha = false
	end;
	function KeyDown(k4)
		fT = true;
		if k4 == "z" and h6 == false then
			Zone()
		end
	end;
	function KeyUp(k4)
		fT = false
	end;
	eP.Button1Down:connect(function(k5)
		MouseDown(k5)
	end)
	eP.Button1Up:connect(function(k5)
		MouseUp(k5)
	end)
	eP.KeyDown:connect(function(k5)
		KeyDown(k5)
	end)
	eP.KeyUp:connect(function(k5)
		KeyUp(k5)
	end)
	function unanchor()
		if hn == true then
			g = hl:GetChildren()
			for b = 1, #g do
				if g[b].ClassName == "Part" then
					g[b].Anchored = false
				end
			end
		end
	end;
	Humanoid.Changed:connect(function(k6)
		if k6 == "Jump" and Disable_Jump == true then
			Humanoid.Jump = false
		end
	end)
	local k7 = 0;
	local k8 = nil;
	while true do
		Swait()
		eA.Parent = nil;
		if Character:FindFirstChildOfClass("Humanoid") == nil then
			Humanoid = IT("Humanoid", Character)
		end;
		for a3, v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop()
		end;
		local gL = Humanoid.WalkSpeed * 2;
		local gZ = RootPart.Velocity * VT(1, 0, 1).magnitude;
		local g_ = RootPart.Velocity.y;
		local k9 = 0;
		local h0 = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 5, Character)
		local h1 = 6 / (Humanoid.WalkSpeed / 16)
		fV = fV + fQ;
		if fS == "Walk" and gZ > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, fX * CF(0, 0, -0.15 * COS(fV / (h1 / 2))) * ANGLES(RAD(-g_), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * Humanoid.WalkSpeed / 16 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(fV / (h1 / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * Humanoid.WalkSpeed / 16 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.555 * SIN(fV / h1) - 0.15 * COS(fV / h1 * 2), -0.7 * COS(fV / h1) + 0.2 + 0.2 * COS(fV / h1)) * ANGLES(RAD(0), RAD(90), RAD(-g_)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(fV / h1))), 0.2 * Humanoid.WalkSpeed / 16 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.555 * SIN(fV / h1) - 0.15 * COS(fV / h1 * 2), 0.7 * COS(fV / h1) + 0.2 + -0.2 * COS(fV / h1)) * ANGLES(RAD(0), RAD(-90), RAD(-g_)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(fV / h1))), 0.2 * Humanoid.WalkSpeed / 16 / Animation_Speed)
		elseif fS ~= "Walk" or gZ < 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, fX * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		end;
		if g_ > 1 and h0 == nil then
			fS = "Jump"
			if h6 == false then
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(-25 - 2.5 * SIN(fV / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * fZ, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * f_, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		elseif g_ < -1 and h0 == nil then
			fS = "Fall"
			if h6 == false then
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 + 0.05 * COS(fV / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(fV / 8))), 0.5 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(fV / 8))), 0.5 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * fZ, 0.5 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * f_, 0.5 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(fV / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			end
		elseif gZ < 1 and h0 ~= nil then
			fS = "Idle"
			if h6 == false then
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0, 0 - 0.1 * SIN(fV / 25)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(0), RAD(8 * SIN(fV / 26)), RAD(-25 - 8.5 * SIN(fV / 25))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(8 * SIN(fV / 26)), RAD(-10), RAD(6 + 8.5 * SIN(fV / 25))) * fZ, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8, 0.4, -0.7) * ANGLES(RAD(90), RAD(0), RAD(86)) * f_, 0.15 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(fV / 25), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(fV / 25), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			end
		elseif gZ > 1 and h0 ~= nil then
			fS = "Walk"
			if h6 == false then
				RootJoint.C0 = Clerp(RootJoint.C0, fX * CF(0, 0.3, 0) * ANGLES(RAD(16), RAD(0), RAD(10 * COS(fV / h1))), 0.15 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, fY * CF(0, 0, 0 + 1 - 1) * ANGLES(RAD(-16 - 8.5 * SIN(fV / h1)), RAD(0), RAD(-10 * COS(fV / h1))), 0.15 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-10), RAD(6)) * fZ, 0.15 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-(8 + gL * 1.25) * COS(fV / h1)), RAD(0), RAD(-22 * COS(fV / h1))) * f_, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(86 - 35 * COS(fV / h1)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(fV / h1)), RAD(0)), 0.15 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86 - 35 * COS(fV / h1)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(fV / h1)), RAD(0)), 0.15 / Animation_Speed)
			end
		end;
		unanchor()
		Humanoid.MaxHealth = "inf"
		Humanoid.Health = "inf"
		if hd == false then
			Disable_Jump = false;
			Humanoid.WalkSpeed = dx
		elseif hd == true then
			Disable_Jump = true;
			Humanoid.WalkSpeed = 0
		end;
		h7.SoundId = "rbxassetid://" .. h8;
		h7.Looped = true;
		h7.Pitch = eg;
		h7.Volume = ef;
		h7.Playing = true;
		h7.EmitterSize = 35;
		if h7.Parent ~= RootPart then
			print("Fixing music")
			h7 = IT("Sound", RootPart)
			h7.SoundId = "rbxassetid://" .. h8;
			h7.Looped = true;
			h7.Pitch = eg;
			h7.Volume = ef;
			h7.Playing = true;
			h7.EmitterSize = 25;
			h7.TimePosition = TIMESTAMP;
			FIXING = true
		elseif FIXING == false then
			TIMESTAMP = h7.TimePosition
		else
			FIXING = false
		end
	end
end)
j:CreateButton("Krystal Dance", function()
	Player = game.Players.LocalPlayer;
	Character = Player.Character.Shiba;
	hum = Character.Humanoid;
	LeftArm = Character["Left Arm"]
	LeftLeg = Character["Left Leg"]
	RightArm = Character["Right Arm"]
	RightLeg = Character["Right Leg"]
	Root = Character["HumanoidRootPart"]
	Head = Character["Head"]
	Torso = Character["Torso"]
	Neck = Torso["Neck"]
	mouse = Player:GetMouse()
	walking = false;
	jumping = false;
	attacking = false;
	firsttime = false;
	tauntdebounce = false;
	position = nil;
	MseGuide = true;
	running = false;
	settime = 0;
	sine = 0;
	t = 0;
	ws = 14;
	change = 1;
	combo1 = true;
	dancing = false;
	equip = false;
	dgs = 75;
	combo2 = false;
	switch1 = true;
	switch2 = false;
	firsttime2 = false;
	combo3 = false;
	gunallowance = false;
	shooting = false;
	RunSrv = game:GetService("RunService")
	RenderStepped = game:GetService("RunService").RenderStepped;
	removeuseless = game:GetService("Debris")
	screenGui = Instance.new("ScreenGui")
	screenGui.Parent = script.Parent;
	local ka = Instance.new("ManualWeld")
	ka.Parent = Head;
	ka.Part0 = Head;
	ka.Part1 = Head;
	ka.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local kb = Instance.new("ManualWeld")
	kb.Parent = Root;
	kb.Part0 = Torso;
	kb.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local kc = Instance.new("ManualWeld")
	kc.Parent = Root;
	kc.Part0 = Root;
	kc.Part1 = Torso;
	kc.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local kd = Instance.new("ManualWeld")
	kd.Parent = RightArm;
	kd.Part0 = RightArm;
	kd.Part1 = Torso;
	kd.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local ke = Instance.new("ManualWeld")
	ke.Parent = LeftArm;
	ke.Part0 = LeftArm;
	ke.Part1 = Torso;
	ke.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local kf = Instance.new("ManualWeld")
	kf.Parent = RightLeg;
	kf.Part0 = RightLeg;
	kf.Part1 = Torso;
	kf.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local kg = Instance.new("ManualWeld")
	kg.Parent = LeftLeg;
	kg.Part0 = LeftLeg;
	kg.Part1 = Torso;
	kg.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local function hA(a, j)
		local hW = Instance.new("ManualWeld", a)
		hW.Part0 = a;
		hW.Part1 = j;
		hW.C0 = a.CFrame:inverse() * j.CFrame;
		return hW
	end;
	function MAKETRAIL(ee, kh, ki, kj, hs)
		A = Instance.new("Attachment", ee)
		A.Position = kh;
		A.Name = "A"
		B = Instance.new("Attachment", ee)
		B.Position = ki;
		B.Name = "B"
		tr1 = Instance.new("Trail", ee)
		tr1.Attachment0 = A;
		tr1.Attachment1 = B;
		tr1.Enabled = true;
		tr1.Lifetime = kj;
		tr1.TextureMode = "Static"
		tr1.LightInfluence = 0;
		tr1.Color = hs;
		tr1.Transparency = NumberSequence.new(0, 1)
	end;
	introsound = Instance.new("Sound", Head)
	introsound.SoundId = "rbxassetid://236146895"
	introsound.Volume = 8;
	introsound:Play()
	fedora = Instance.new("Part", Character)
	fedora.Size = Vector3.new(2, 2, 2)
	fedora.CFrame = Head.CFrame;
	fedora.CanCollide = false;
	fedora.Transparency = 1;
	fedoraweld = Instance.new("Weld", fedora)
	fedoraweld.Part0 = fedora;
	fedoraweld.Part1 = Head;
	fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0, -.75, 0)
	mfedora = Instance.new("SpecialMesh", fedora)
	mfedora.MeshType = "FileMesh"
	mfedora.Scale = Vector3.new(.97, .97, .97)
	mfedora.MeshId, mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868', 'http://www.roblox.com/asset/?id=18987684'
	shades = Instance.new("Part", Character)
	shades.Size = Vector3.new(2, 2, 2)
	shades.CFrame = Head.CFrame;
	shades.CanCollide = false;
	shades.Transparency = 1;
	shadesweld = Instance.new("Weld", shades)
	shadesweld.Part0 = shades;
	shadesweld.Part1 = Head;
	shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0, -.2, .15)
	mshades = Instance.new("SpecialMesh", shades)
	mshades.MeshType = "FileMesh"
	mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
	mshades.MeshId, mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360', 'http://www.roblox.com/asset/?id=1577349'
	coroutine.wrap(function()
		while wait() do
			Head.face.Texture = "rbxasset://textures/face.png"
			hum.WalkSpeed = ws
		end
	end)()
	coroutine.wrap(function()
		for b, v in pairs(Character:GetChildren()) do
			if v.Name == "Animate" then
				v:Remove()
			end
		end
	end)()
	function damagealll(kk, Position)
	end;
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")
	frame = 1 / 60;
	tf = 0;
	allowframeloss = false;
	tossremainder = false;
	lastframe = tick()
	script.Heartbeat:Fire()
	game:GetService("RunService").Heartbeat:connect(function(am, aG)
		tf = tf + am;
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for b = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end;
				lastframe = tick()
			end;
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	function swait(ac)
		if ac == 0 or ac == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for b = 0, ac do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end;
	intro = true;
	ws = 0;
	bigfedora = Instance.new("Part", Character)
	bigfedora.Size = Vector3.new(2, 2, 2)
	bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60, 60), -.2, math.random(-60, 60)) * CFrame.Angles(0, math.rad(math.random(-180, 180)), 0)
	bigfedora.CanCollide = false;
	bigfedora.Anchored = true;
	bigfedora.Name = "mbigf"
	mbigfedora = Instance.new("SpecialMesh", bigfedora)
	mbigfedora.MeshType = "FileMesh"
	mbigfedora.Scale = Vector3.new(6, 7, 7)
	mbigfedora.MeshId, mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868', 'http://www.roblox.com/asset/?id=18987684'
	for b = 1, 60 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0, -.1, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .09)
		swait()
	end;
	for b = 1, 50 do
		bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position), .05)
		swait()
	end;
	zmc = 0;
	for b = 1, 29 do
		zmc = zmc + 2;
		mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25, .25, .25)
		bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0), math.rad(zmc), 0)
		swait()
	end;
	bigfedora:Remove()
	ws = 14;
	function SOUND(ee, ed, kl, g7, km)
		so = Instance.new("Sound")
		so.Parent = ee;
		so.SoundId = "rbxassetid://" .. ed;
		so.Volume = kl;
		so.Looped = g7;
		so:Play()
		removeuseless:AddItem(so, km)
	end;
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'k' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				jam = Instance.new("Sound", Torso)
				jam.SoundId = "rbxassetid://665751753"
				jam.Volume = 8;
				jam.Looped = true;
				jam.TimePosition = 22.3;
				jam:Play()
				lol90 = 0;
				coroutine.wrap(function()
					while dancing do
						lol90 = lol90 + 11;
						kc.C0 = kc.C0:Lerp(CFrame.new(1 * math.sin(sine / 10), .1 + .8 * math.sin(sine / 3), 0) * CFrame.Angles(math.rad(0), math.rad(0 * math.sin(sine / 8)), math.rad(8 * math.sin(sine / 7))), .25)
						kc.C1 = kc.C1:lerp(CFrame.new(0 * math.sin(sine / 14), 0, 0) * CFrame.Angles(math.rad(0), math.rad(lol90), 0), .25)
						ke.C0 = ke.C0:lerp(CFrame.new(1.4, 1.45, 0) * CFrame.Angles(math.rad(180), math.rad(-5 * math.sin(sine / 3)), math.rad(-6 * math.sin(sine / 3))), 0.25)
						kd.C0 = kd.C0:lerp(CFrame.new(-1.4, 1.45, 0) * CFrame.Angles(math.rad(180), math.rad(5 * math.sin(sine / 3)), math.rad(6 * math.sin(sine / 3))), 0.25)
						kf.C0 = kf.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine / 3))), 0.25)
						kg.C0 = kg.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine / 3))), 0.25)
						swait()
					end;
					ws = 14;
					jam:Remove()
					kc.C1 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'j' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 3;
				change = .5;
				attacking = true;
				g1 = Instance.new("BodyGyro", Root)
				g1.D = 175;
				g1.P = 20000;
				g1.MaxTorque = Vector3.new(0, 9000, 0)
				herecomesthemoney = Instance.new("Sound", Torso)
				herecomesthemoney.Pitch = 1;
				herecomesthemoney.SoundId = "rbxassetid://2426693638"
				herecomesthemoney.Volume = 8;
				herecomesthemoney.Looped = true;
				herecomesthemoney:Play()
				robuxpile = Instance.new("Part", Torso)
				robuxpile.Size = Vector3.new(1, 1, 1)
				robuxpile.CFrame = LeftArm.CFrame;
				robuxpile.CanCollide = false;
				robuxpileweld = Instance.new("Weld", robuxpile)
				robuxpileweld.Part0 = robuxpile;
				robuxpileweld.Part1 = Torso;
				robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1, -.7, 1.4)
				mrobuxpile = Instance.new("SpecialMesh", robuxpile)
				mrobuxpile.MeshType = "FileMesh"
				mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
				mrobuxpile.MeshId, mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245', 'http://www.roblox.com/asset/?id=8587344'
				coroutine.wrap(function()
					coroutine.wrap(function()
						while wait(.35) do
							if not dancing then
								break
							end;
							local ko = Instance.new("Part", Torso)
							ko.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0), math.rad(90), math.rad(90))
							ko.Anchored = false;
							ko.CanCollide = true;
							ko.Size = Vector3.new(1, 1, 1)
							removeuseless:AddItem(ko, 4)
							mrobux = Instance.new("SpecialMesh", ko)
							mrobux.MeshType = "FileMesh"
							mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
							mrobux.MeshId, mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348', 'http://www.roblox.com/asset/?id=665939136'
							bov = Instance.new("BodyVelocity", ko)
							bov.maxForce = Vector3.new(99999, 99999, 99999)
							ko.CFrame = CFrame.new(ko.Position, mouse.Hit.p)
							bov.velocity = ko.CFrame.lookVector * 45;
							removeuseless:AddItem(bov, .1)
						end
					end)()
					while dancing do
						g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position, mouse.Hit.p), .4)
						kc.C0 = kc.C0:Lerp(CFrame.new(0, -.3, 0) * CFrame.Angles(math.rad(20), math.rad(0 * math.sin(sine / 8)), math.rad(0)), .25)
						ke.C0 = ke.C0:lerp(CFrame.new(1, .5 + .5 * math.sin(sine / 2), .5) * CFrame.Angles(math.rad(-97), math.rad(40 - 20 * math.sin(sine / 2)), math.rad(0)), 0.25)
						kd.C0 = kd.C0:lerp(CFrame.new(-1, .5, .5) * CFrame.Angles(math.rad(-87), math.rad(-20), math.rad(0)), 0.25)
						kf.C0 = kf.C0:lerp(CFrame.new(-0.3, 2, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
						kg.C0 = kg.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
						swait()
					end;
					ws = 14;
					removeuseless:AddItem(g1, .001)
					robuxpile:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'h' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				jellyfishjam = Instance.new("Sound", Torso)
				jellyfishjam.SoundId = "rbxassetid://840189092"
				jellyfishjam.Volume = 8;
				jellyfishjam.Looped = true;
				jellyfishjam.TimePosition = 14.8;
				jellyfishjam:Play()
				coroutine.wrap(function()
					while dancing do
						for b = 1, 15 do
							if not dancing then
								break
							end;
							kc.C0 = kc.C0:Lerp(CFrame.new(.5, -.4 + .1 * math.sin(sine / 4), 0) * CFrame.Angles(math.rad(0), math.rad(20 * math.sin(sine / 8)), math.rad(20)), .25)
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .3)
							ke.C0 = ke.C0:lerp(CFrame.new(.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(-50 - 3 * math.sin(sine / 12)), math.rad(-3 + 1 * math.sin(sine / 12))), .3)
							kf.C0 = kf.C0:lerp(CFrame.new(0.25, 2.05, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
							kg.C0 = kg.C0:lerp(CFrame.new(0.31, 2.05, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
							swait()
						end;
						for b = 1, 15 do
							if not dancing then
								break
							end;
							kc.C0 = kc.C0:Lerp(CFrame.new(0, -.1 * math.sin(sine / 4), 0) * CFrame.Angles(math.rad(0), math.rad(20 * math.sin(sine / 8)), math.rad(0)), .25)
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .3)
							ke.C0 = ke.C0:lerp(CFrame.new(.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(-50 - 3 * math.sin(sine / 12)), math.rad(-3 + 1 * math.sin(sine / 12))), .3)
							kf.C0 = kf.C0:lerp(CFrame.new(-0.25, .7, 1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
							kg.C0 = kg.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
							swait()
						end;
						for b = 1, 15 do
							if not dancing then
								break
							end;
							kc.C0 = kc.C0:Lerp(CFrame.new(-.5, -.4 + .1 * math.sin(sine / 4), 0) * CFrame.Angles(math.rad(0), math.rad(20 * math.sin(sine / 8)), math.rad(-20)), .25)
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .3)
							ke.C0 = ke.C0:lerp(CFrame.new(.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(-50 - 3 * math.sin(sine / 12)), math.rad(-3 + 1 * math.sin(sine / 12))), .3)
							kf.C0 = kf.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
							kg.C0 = kg.C0:lerp(CFrame.new(-0.25, 2.05, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
							swait()
						end;
						for b = 1, 15 do
							if not dancing then
								break
							end;
							kc.C0 = kc.C0:Lerp(CFrame.new(-.5, -.1, 0) * CFrame.Angles(math.rad(0), math.rad(20 * math.sin(sine / 8)), math.rad(0)), .25)
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .3)
							ke.C0 = ke.C0:lerp(CFrame.new(.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(-50 - 3 * math.sin(sine / 12)), math.rad(-3 + 1 * math.sin(sine / 12))), .3)
							kf.C0 = kf.C0:lerp(CFrame.new(-0.31, 2.05, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
							kg.C0 = kg.C0:lerp(CFrame.new(0.25, .7, 1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
							swait()
						end;
						swait()
					end;
					ws = 14;
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'g' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				deadmau7 = Instance.new("Sound", Torso)
				deadmau7.SoundId = "rbxassetid://168166611"
				deadmau7.Volume = 8;
				deadmau7.Looped = true;
				deadmau7:Play()
				coroutine.wrap(function()
					coroutine.wrap(function()
						while dancing do
							kc.C0 = kc.C0:Lerp(CFrame.new(2 * math.sin(sine / 9), -.4 + .1 * math.sin(sine / 3), 0) * CFrame.Angles(math.rad(0), math.rad(20 * math.sin(sine / 9)), 0), .25)
							swait()
						end
					end)()
					while dancing do
						for b = 1, 28 do
							if not dancing then
								break
							end;
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(1.2, 1.5, 0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine / 3)), math.rad(7 * math.sin(sine / 3)), math.rad(7 * math.sin(sine / 3))), 0.2)
							kf.C0 = kf.C0:lerp(CFrame.new(-0.5, .7, 1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine / 2)), math.rad(0), math.rad(0)), 0.25)
							kg.C0 = kg.C0:lerp(CFrame.new(0.31, 2.05, -.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
							swait()
						end;
						for b = 1, 28 do
							if not dancing then
								break
							end;
							kd.C0 = kd.C0:lerp(CFrame.new(-.9, .65 + .4 * math.sin(sine / 12), 1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine / 12)), math.rad(50 + 3 * math.sin(sine / 12)), math.rad(3 - 1 * math.sin(sine / 12))), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(1.2, 1.5, 0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine / 3)), math.rad(7 * math.sin(sine / 3)), math.rad(7 * math.sin(sine / 3))), 0.2)
							kf.C0 = kf.C0:lerp(CFrame.new(-0.31, 2.05, .1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
							kg.C0 = kg.C0:lerp(CFrame.new(0.5, .7, 1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine / 2)), math.rad(0), math.rad(-2)), 0.25)
							swait()
						end;
						swait()
					end;
					ws = 14;
					deadmau7:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'f' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 6;
				change = .5;
				attacking = true;
				bennyhill = Instance.new("Sound", Torso)
				bennyhill.SoundId = "rbxassetid://138211362"
				bennyhill.Volume = 8;
				bennyhill.Looped = true;
				bennyhill:Play()
				coroutine.wrap(function()
					while dancing do
						kc.C0 = kc.C0:Lerp(CFrame.new(0, -.4, 0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine / 2)), math.rad(10 * math.sin(sine / 4)), 0), .25)
						kd.C0 = kd.C0:lerp(CFrame.new(-1.5, .89 - .4 * -math.sin(sine / 2), .49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine / 2)), 0, math.rad(0)), .25)
						ke.C0 = ke.C0:lerp(CFrame.new(1.5, .89 - .4 * math.sin(sine / 2), .49) * CFrame.Angles(math.rad(-70 + 20 * math.sin(sine / 2)), 0, math.rad(0)), .25)
						kf.C0 = kf.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine / 2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine / 2)), math.rad(0), math.rad(-8)), 0.25)
						kg.C0 = kg.C0:lerp(CFrame.new(0.33, 2.0, -.2 - .3 * math.sin(sine / 2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine / 2)), math.rad(0), math.rad(8)), 0.25)
						swait()
					end;
					ws = 14;
					bennyhill:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'p' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				barrelspin = 0;
				barrelrollsound = Instance.new("Sound", Torso)
				barrelrollsound.SoundId = "rbxassetid://505320170"
				barrelrollsound.Volume = 8;
				barrelrollsound.Looped = true;
				barrelrollsound:Play()
				barrol = Instance.new("Part", Torso)
				barrol.Size = Vector3.new(1, 1, 1)
				barrol.CFrame = Torso.CFrame;
				barrol.CanCollide = false;
				barrolweld = Instance.new("Weld", barrol)
				barrolweld.Part0 = barrol;
				barrolweld.Part1 = Torso;
				barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0, 0, 0)
				mbarrol = Instance.new("SpecialMesh", barrol)
				mbarrol.MeshType = "FileMesh"
				mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
				mbarrol.MeshId, mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142', 'http://www.roblox.com/asset/?id=31082268'
				coroutine.wrap(function()
					while dancing do
						kc.C0 = kc.C0:Lerp(CFrame.new(5 * math.sin(sine / 8), -1.8, 0) * CFrame.Angles(math.rad(-90), math.rad(180 * math.sin(sine / 8)), 0), .25)
						kd.C0 = kd.C0:lerp(CFrame.new(-1.5, 1.5, 0) * CFrame.Angles(math.rad(180), 0, math.rad(0)), .25)
						ke.C0 = ke.C0:lerp(CFrame.new(1.5, 1.5, 0) * CFrame.Angles(math.rad(180), 0, math.rad(0)), .25)
						kg.C0 = kg.C0:lerp(CFrame.new(.5, 2, 0) * CFrame.Angles(0, 0, 0), .25)
						kf.C0 = kf.C0:lerp(CFrame.new(-.5, 2, 0) * CFrame.Angles(0, 0, 0), .25)
						swait()
					end;
					ws = 14;
					barrol:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'q' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				spinningmove = 0;
				dbwouldlovethis = Instance.new("Sound", Torso)
				dbwouldlovethis.SoundId = "rbxassetid://1532157598"
				dbwouldlovethis.Volume = 8;
				dbwouldlovethis.Looped = true;
				dbwouldlovethis:Play()
				attacking = true;
				coroutine.wrap(function()
					while dancing do
						spinningmove = spinningmove + 10;
						kf.C0 = kf.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), .2)
						kg.C0 = kg.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), .2)
						kc.C0 = kc.C0:lerp(CFrame.new(.2 * math.sin(sine / 3), -.52, .2 * math.sin(sine / 4)) * CFrame.Angles(math.rad(180), math.rad(spinningmove), math.rad(15 * math.sin(sine / 9))), .2)
						ke.C0 = ke.C0:lerp(CFrame.new(1.4, 1.45, 0) * CFrame.Angles(math.rad(180), math.rad(-1), math.rad(-3 * math.sin(sine / 2))), 0.3)
						kd.C0 = kd.C0:lerp(CFrame.new(-1.4, 1.45, 0) * CFrame.Angles(math.rad(180), math.rad(1), math.rad(3 * math.sin(sine / 2))), 0.3)
						swait()
					end;
					ws = 14;
					dbwouldlovethis:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'u' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 6;
				change = .5;
				attacking = true;
				slavdance = Instance.new("Sound", Torso)
				slavdance.SoundId = "rbxassetid://2341226836"
				slavdance.Volume = 6;
				slavdance.Looped = true;
				slavdance:Play()
				coroutine.wrap(function()
					while dancing do
						for b = 1, 17 do
							if not dancing then
								break
							end;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)), .2)
							kg.C0 = kg.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), .2)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine / 3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine / 3)), math.rad(0), math.rad(0)), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(1, -.2, .4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine / 9)), math.rad(80 - 3 * math.sin(sine / 9)), math.rad(0)), 0.3)
							kd.C0 = kd.C0:lerp(CFrame.new(-.7, -.2, .4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine / 9)), math.rad(-88 + .7 * math.sin(sine / 9)), math.rad(0)), 0.3)
							swait()
						end;
						for b = 1, 17 do
							if not dancing then
								break
							end;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)), .2)
							kg.C0 = kg.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)), .2)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine / 3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine / 3)), math.rad(0), math.rad(0)), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(1, -.2, .4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine / 9)), math.rad(80 - 3 * math.sin(sine / 9)), math.rad(0)), 0.3)
							kd.C0 = kd.C0:lerp(CFrame.new(-.7, -.2, .4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine / 9)), math.rad(-88 + .7 * math.sin(sine / 9)), math.rad(0)), 0.3)
							swait()
						end;
						swait()
					end;
					ws = 14;
					slavdance:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'y' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				walkforward = 0;
				walkrotation = 0;
				attacking = true;
				truelegend = Instance.new("Sound", Torso)
				truelegend.SoundId = "rbxassetid://487872908"
				truelegend.TimePosition = 13.98;
				truelegend.Volume = 8;
				truelegend.Looped = true;
				truelegend:Play()
				coroutine.wrap(function()
					while dancing do
						for b = 1, 100 do
							if not dancing then
								break
							end;
							walkforward = walkforward + .1;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.31, 2.05, .1 * math.sin(sine / 4)) * CFrame.Angles(math.rad(10 * math.sin(sine / 4)), math.rad(0), math.rad(-8)), 0.3)
							kg.C0 = kg.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine / 4)) * CFrame.Angles(math.rad(-10 * math.sin(sine / 4)), math.rad(0), math.rad(8)), 0.3)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .2)
							kd.C0 = kd.C0:lerp(CFrame.new(-1.5, 0, 0) * CFrame.Angles(0, 0, math.rad(0)), .3)
							ke.C0 = ke.C0:lerp(CFrame.new(1.5, 0, 0) * CFrame.Angles(0, 0, math.rad(0)), .3)
							swait()
						end;
						for b = 1, 50 do
							if not dancing then
								break
							end;
							walkrotation = walkrotation + 15;
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0), math.rad(walkrotation), math.rad(-0)), .2)
							swait()
						end;
						walkrotation = 0;
						for b = 1, 100 do
							if not dancing then
								break
							end;
							walkforward = walkforward - .1;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.31, 2, .1 * math.sin(sine / 4)) * CFrame.Angles(math.rad(10 * math.sin(sine / 4)), math.rad(0), math.rad(-8)), 0.3)
							kg.C0 = kg.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine / 4)) * CFrame.Angles(math.rad(-10 * math.sin(sine / 4)), math.rad(0), math.rad(8)), 0.3)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0), math.rad(-180), math.rad(-0)), .2)
							kd.C0 = kd.C0:lerp(CFrame.new(-1.3, .7, .2) * CFrame.Angles(math.rad(220), math.rad(0), math.rad(-30)), 0.4)
							ke.C0 = ke.C0:lerp(CFrame.new(1.5, 0, 0) * CFrame.Angles(0, 0, math.rad(0)), .3)
							swait()
						end;
						for b = 1, 50 do
							if not dancing then
								break
							end;
							walkrotation = walkrotation + 15;
							kd.C0 = kd.C0:lerp(CFrame.new(-1.5, 0, 0) * CFrame.Angles(0, 0, math.rad(0)), .1)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0), math.rad(walkrotation), math.rad(-0)), .2)
							swait()
						end;
						walkrotation = 0;
						swait()
					end;
					ws = 14;
					truelegend:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 't' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				plummusic = Instance.new("Sound", Torso)
				plummusic.Volume = 8;
				plummusic.Looped = true;
				plummusic.SoundId = "rbxassetid://2526093213"
				plummusic:Play()
				coroutine.wrap(function()
					while dancing do
						for b = 1, 20 do
							if not dancing then
								break
							end;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							kg.C0 = kg.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0 * math.sin(sine / 4)), math.rad(15)), .2)
							kd.C0 = kd.C0:lerp(CFrame.new(.5, 1.98, .05) * CFrame.Angles(0, 0, math.rad(-140)), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(1, 1.3, .05) * CFrame.Angles(0, 0, math.rad(50)), .2)
							swait()
						end;
						for b = 1, 20 do
							if not dancing then
								break
							end;
							kf.C0 = kf.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
							kg.C0 = kg.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
							kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0 * math.sin(sine / 4)), math.rad(-15)), .2)
							kd.C0 = kd.C0:lerp(CFrame.new(-1, 1.4, .05) * CFrame.Angles(0, 0, math.rad(-50)), .2)
							ke.C0 = ke.C0:lerp(CFrame.new(-.6, 2, .05) * CFrame.Angles(0, 0, math.rad(140)), .2)
							swait()
						end;
						swait()
					end;
					ws = 14;
					plummusic:Remove()
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'e' then
			if dancing then
				dancing = false
			else
				dancing = true;
				ws = 0;
				change = .5;
				attacking = true;
				mrozo = Instance.new("Sound", Torso)
				mrozo.Volume = 8;
				mrozo.SoundId = "rbxassetid://335701357"
				mrozo.Looped = true;
				mrozo.TimePosition = 10;
				mrozo:Play()
				coroutine.wrap(function()
					while dancing do
						kf.C0 = kf.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
						kg.C0 = kg.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
						kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0 * math.sin(sine / 4)), math.rad(15 * math.sin(sine / 4))), .2)
						kd.C0 = kd.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine / 3.5), .5 * -math.sin(sine / 3.5), .1) * CFrame.Angles(math.rad(0 * math.sin(sine / 2)), 0, math.rad(30 * math.sin(sine / 3.5))), .2)
						ke.C0 = ke.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine / 3.5), .5 * math.sin(sine / 3.5), .1) * CFrame.Angles(math.rad(0 * math.sin(sine / 2)), 0, math.rad(30 * math.sin(sine / 3.5))), .2)
						swait()
					end;
					mrozo:Remove()
					ws = 14;
					attacking = false
				end)()
			end
		end
	end)
	mouse.KeyDown:connect(function(kn)
		kn = kn:lower()
		if kn == 'r' then
			if dancing then
				dancing = false
			else
				ws = 6;
				recordbaby = 0;
				dancing = true;
				change = .5;
				attacking = true;
				spinme = Instance.new("Sound", Torso)
				spinme.Volume = 8;
				spinme.SoundId = "rbxassetid://145799973"
				spinme.Looped = true;
				spinme:Play()
				coroutine.wrap(function()
					while dancing do
						recordbaby = recordbaby + 10;
						kf.C0 = kf.C0:lerp(CFrame.new(-0.27, 2, .1 * math.sin(sine / 4)) * CFrame.Angles(math.rad(10 * math.sin(sine / 4)), math.rad(0), math.rad(-8)), 0.3)
						kg.C0 = kg.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine / 4)) * CFrame.Angles(math.rad(-10 * math.sin(sine / 4)), math.rad(0), math.rad(8)), 0.3)
						kc.C0 = kc.C0:lerp(CFrame.new(.5 * math.sin(sine / 5), -.2, .5 * math.sin(sine / 4)) * CFrame.Angles(math.rad(0), math.rad(recordbaby), math.rad(0)), .3)
						kd.C0 = kd.C0:lerp(CFrame.new(-.5, 1.98, 0) * CFrame.Angles(0, 0, math.rad(-90)), .3)
						ke.C0 = ke.C0:lerp(CFrame.new(.5, 1.98, 0) * CFrame.Angles(0, 0, math.rad(90)), .3)
						swait()
					end;
					spinme:Remove()
					ws = 14;
					attacking = false
				end)()
			end
		end
	end)
	function ray(aj, kp, kq, kr)
		return workspace:FindPartOnRay(Ray.new(aj, kp.unit * kq), kr)
	end;
	function ray2(ks, kt, ku, kv)
		local kp = CFrame.new(ks, kt).lookVector;
		return ray(ks, kp, ku, kv)
	end;
	checks1 = coroutine.wrap(function()
		while true do
			hf = ray(Root.Position, CFrame.new(Root.Position, Root.Position + Vector3.new(0, -1, 0)).lookVector, 3 * 3, Character)
			if Root.Velocity.y > 1 then
				position = "Jump"
			elseif Root.Velocity.y < -1 then
				position = "Falling"
			elseif Root.Velocity.Magnitude < 2 then
				position = "Idle"
			elseif Root.Velocity.Magnitude > 2 then
				position = "Walking"
			elseif Root.Velocity.Magnitude > 20 then
				position = "Running"
			else
			end;
			wait()
		end
	end)
	checks1()
	function ray(gv, gw, gf, gx)
		return workspace:FindPartOnRay(Ray.new(gv, gw.unit * gf), gx)
	end;
	function ray2(iE, iF, e2, cM)
		local gw = CFrame.new(iE, iF).lookVector;
		return ray(iE, gw, e2, cM)
	end;
	OrgnC0 = Neck.C0;
	local kw = coroutine.wrap(function()
		while RunSrv.RenderStepped:wait() do
			TrsoLV = Torso.CFrame.lookVector;
			Dist = nil;
			Diff = nil;
			if not MseGuide then
				print("Failed to recognize")
			else
				local a3, kx = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist = Head.CFrame.p - kx.magnitude;
				Diff = Head.CFrame.Y - kx.Y;
				local a3, ky = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
				Dist2 = LeftArm.CFrame.p - kx.magnitude;
				Diff2 = LeftArm.CFrame.Y - kx.Y;
				ka.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
				Neck.C0 = Neck.C0:lerp(OrgnC0 * CFrame.Angles(math.tan(Diff / Dist) * 1, 0, Head.CFrame.p - kx.Unit:Cross(Torso.CFrame.lookVector).Y * 1), .1)
			end
		end
	end)
	kw()
	immortal = {}
	for b, v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
			if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
				v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
			end;
			table.insert(immortal, {
				v,
				v.Parent,
				v.Material,
				v.Color,
				v.Transparency
			})
		elseif v:IsA("JointInstance") then
			table.insert(immortal, {
				v,
				v.Parent,
				nil,
				nil,
				nil
			})
		end
	end;
	for eH = 1, #immortal do
		if immortal[eH] ~= nil then
			local hq = immortal[eH]
			local hr = hq[1]
			local ee = hq[2]
			local gn = hq[3]
			local hs = hq[4]
			local gp = hq[5]
			if levitate then
				if hr.ClassName == "Part" and hr ~= Root and hr.Name ~= eyo1 and hr.Name ~= eyo2 and hr.Name ~= "lmagic" and hr.Name ~= "rmagic" then
					hr.Material = gn;
					hr.Color = hs;
					hr.Transparency = gp
				end;
				hr.AncestryChanged:connect(function()
					hr.Parent = ee
				end)
			else
				if hr.ClassName == "Part" and hr ~= Root and hr.Name ~= "lmagic" and hr.Name ~= "rmagic" then
					hr.Material = gn;
					hr.Color = hs;
					hr.Transparency = gp
				end;
				hr.AncestryChanged:connect(function()
					hr.Parent = ee
				end)
			end
		end
	end;
	function immortality()
		for eH = 1, #immortal do
			if immortal[eH] ~= nil then
				local hq = immortal[eH]
				local hr = hq[1]
				local ee = hq[2]
				local gn = hq[3]
				local hs = hq[4]
				local gp = hq[5]
				if hr.ClassName == "Part" and hr == Root then
					hr.Material = gn;
					hr.Color = hs;
					hr.Transparency = gp
				end;
				if hr.Parent ~= ee then
					hum:Remove()
					hr.Parent = ee
				end
			end
		end
	end;
	coroutine.wrap(function()
		while true do
			if hum.Health < .1 then
				deadsound = Instance.new("Sound", Torso)
				deadsound.Volume = 6;
				deadsound.SoundId = "rbxassetid://1411352723"
				deadsound:Play()
				immortality()
			end;
			wait()
		end
	end)()
	local a7 = coroutine.wrap(function()
		while true do
			settime = 0.05;
			sine = sine + change;
			if position == "Jump" and attacking == false then
				change = 1;
				spin = false;
				for b, v in pairs(Torso:GetChildren()) do
					if v:IsA("Sound") then
						v:Remove()
					end
				end;
				kg.C1 = kg.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), .1)
				kf.C1 = kf.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), 0, 0), .1)
				ke.C1 = ke.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), .4)
				kc.C0 = kc.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
				ke.C0 = ke.C0:lerp(CFrame.new(1.4, .1, -.2) * CFrame.Angles(math.rad(20), math.rad(-3), math.rad(-4)), 0.2)
				kf.C0 = kf.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
				kg.C0 = kg.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
			elseif position == "Falling" and attacking == false then
				change = 1;
				spin = false;
				for b, v in pairs(Torso:GetChildren()) do
					if v:IsA("Sound") then
						v:Remove()
					end
				end;
				kc.C0 = kc.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
				kg.C1 = kg.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), .1)
				kf.C1 = kf.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), 0, 0), .1)
				ke.C1 = ke.C1:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0, 0, 0), .4)
				kf.C0 = kf.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
				kg.C0 = kg.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
				ke.C0 = ke.C0:lerp(CFrame.new(1.5, .94 + .02 * math.sin(sine / 12), -0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine / 12)), math.rad(0), math.rad(45)), 0.2)
				kd.C0 = kd.C0:lerp(CFrame.new(-1.5, .94 + .02 * math.sin(sine / 12), -0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine / 12)), math.rad(0), math.rad(-45)), 0.2)
			elseif position == "Walking" and attacking == false and running == false then
				change = 1.2;
				walking = true;
				spin = false;
				for b, v in pairs(Torso:GetChildren()) do
					if v:IsA("Sound") then
						v:Remove()
					end
				end;
				kd.C0 = kd.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85, .35, -.5 * math.sin(sine / 11)) * CFrame.Angles(math.rad(35 * math.sin(sine / 11)), math.rad(0 * math.sin(sine / 11)), math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine / 4)))), .3)
				ke.C0 = ke.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85, .45, .5 * math.sin(sine / 11)) * CFrame.Angles(math.rad(-55 * math.sin(sine / 11)), math.rad(-5 * math.sin(sine / 8)), math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine / 4)))), .3)
				kc.C0 = kc.C0:lerp(CFrame.new(0, -.15 * 0.6 * -math.sin(sine / 5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine / 11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine / 10))), 0.3)
				kf.C0 = kf.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine / 11) / 2.8, -.2 + 0.2 - math.sin(sine / 11) / 3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine / 11) / 2.3, math.rad(0) * math.cos(sine / 1), math.rad(0), math.cos(-15 * 25 * math.cos(sine / 11))), 0.3)
				kg.C0 = kg.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine / 11) / 2.8, -.2 + 0.2 + math.sin(sine / 11) / 3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine / 11) / 2.3, math.rad(0) * math.cos(sine / 1), math.rad(0), math.cos(-15 * 25 * math.cos(sine / 11))), 0.3)
			elseif position == "Idle" and attacking == false and running == false then
				change = .5;
				spin = true;
				for b, v in pairs(Torso:GetChildren()) do
					if v:IsA("Sound") then
						v:Remove()
					end
				end;
				kc.C0 = kc.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine / 12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine / 12)), math.rad(0), math.rad(0)), .1)
				ke.C0 = ke.C0:lerp(CFrame.new(1.5, .27 + .02 * math.sin(sine / 12), .20 * -math.sin(sine / 12)) * CFrame.Angles(math.rad(20 * math.sin(sine / 12)), math.rad(0), math.rad(10)), 0.1)
				kd.C0 = kd.C0:lerp(CFrame.new(-1.5, .27 + .02 * math.sin(sine / 12), .20 * -math.sin(sine / 12)) * CFrame.Angles(math.rad(20 * math.sin(sine / 12)), math.rad(0), math.rad(-10)), 0.1)
				kf.C0 = kf.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine / 12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine / 12)), math.rad(0), math.rad(-10)), 0.1)
				kg.C0 = kg.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine / 12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine / 12)), math.rad(0), math.rad(10)), 0.1)
			elseif position == "Running" and attacking == false then
				change = 1;
				for b, v in pairs(Torso:GetChildren()) do
					if v:IsA("Sound") then
						v:Remove()
					end
				end;
				kd.C0 = kd.C0:lerp(CFrame.new(0, .5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
				ke.C1 = ke.C1:lerp(CFrame.new(-1.24 + .6 * math.sin(sine / 4) / 1.4, 0.54, 0 - 0.8 * math.sin(sine / 4)) * CFrame.Angles(math.rad(6 + 140 * math.sin(sine / 4) / 1.2), math.rad(0), math.rad(20 + 70 * math.sin(sine / 4))), 0.3)
				ke.C0 = ke.C0:lerp(CFrame.new(0, .5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), .3)
				kc.C0 = kc.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine / 4)), math.rad(0 + 6 * math.sin(sine / 4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine / 4))), 0.3)
				kf.C1 = kf.C1:lerp(CFrame.new(0, 0, -.2 + .5 * -math.sin(sine / 4)), .3)
				kf.C0 = kf.C0:lerp(CFrame.new(-0.5, 1.6 + 0.1 * math.sin(sine / 4), .7 * -math.sin(sine / 4)) * CFrame.Angles(math.rad(15 + -50 * math.sin(sine / 4)), 0, 0), .3)
				kg.C1 = kg.C1:lerp(CFrame.new(0, 0, -.2 + .5 * math.sin(sine / 4)), .3)
				kg.C0 = kg.C0:lerp(CFrame.new(0.5, 1.6 - 0.1 * math.sin(sine / 4), .7 * math.sin(sine / 4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine / 4)), 0, 0), .3)
			end;
			swait()
		end
	end)
	a7()
	warn("Back from the past to dance the dance. Made by Supr14(Credits to Krystalteam).")
end)
